<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Querydsl Reference Guide</title><link rel="stylesheet" href="css/stylesheet.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en-US"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Querydsl Reference Guide</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Timo</span> <span class="surname">Westk&auml;mper</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Samppa</span> <span class="surname">Saarela</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Vesa</span> <span class="surname">Marttila</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Lassi</span> <span class="surname">Immonen</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Ruben</span> <span class="surname">Dijkstra</span></h3></div><div class="author"><h3 class="author"><span class="firstname">John</span> <span class="surname">Tims</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Robert</span> <span class="surname">Bain</span></h3></div></div></div><div><p class="releaseinfo">4.2.2</p></div><div><p class="copyright">Copyright &copy; 2007-2016 The Querydsl Team</p></div><div><div class="legalnotice"><a name="Legal_Notice"></a><p>
        This copyrighted material is made available to
        anyone wishing to use, modify, copy, or redistribute it subject to the terms and conditions of the
        <a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0" target="_top">Apache License, Version 2.0</a>.
    </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#intro">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e87">1.1. Background</a></span></dt><dt><span class="sect1"><a href="#d0e101">1.2. Principles</a></span></dt></dl></dd><dt><span class="chapter"><a href="#tutorials">2. Tutorials</a></span></dt><dd><dl><dt><span class="sect1"><a href="#jpa_integration">2.1. Querying JPA</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e137">2.1.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e161">2.1.2. Ant integration</a></span></dt><dt><span class="sect2"><a href="#d0e179">2.1.3. Using Querydsl JPA in Roo</a></span></dt><dt><span class="sect2"><a href="#d0e201">2.1.4. Generating the model from hbm.xml files</a></span></dt><dt><span class="sect2"><a href="#d0e216">2.1.5. Using query types</a></span></dt><dt><span class="sect2"><a href="#d0e235">2.1.6. Querying</a></span></dt><dt><span class="sect2"><a href="#d0e307">2.1.7. Using joins</a></span></dt><dt><span class="sect2"><a href="#d0e326">2.1.8. General usage</a></span></dt><dt><span class="sect2"><a href="#d0e371">2.1.9. Ordering</a></span></dt><dt><span class="sect2"><a href="#d0e382">2.1.10. Grouping</a></span></dt><dt><span class="sect2"><a href="#d0e393">2.1.11. Delete clauses</a></span></dt><dt><span class="sect2"><a href="#d0e404">2.1.12. Update clauses</a></span></dt><dt><span class="sect2"><a href="#d0e415">2.1.13. Subqueries</a></span></dt><dt><span class="sect2"><a href="#d0e429">2.1.14. Exposing the original query</a></span></dt><dt><span class="sect2"><a href="#d0e436">2.1.15. Using Native SQL in JPA queries</a></span></dt></dl></dd><dt><span class="sect1"><a href="#jdo_integration">2.2. Querying JDO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e487">2.2.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e509">2.2.2. Ant integration</a></span></dt><dt><span class="sect2"><a href="#d0e527">2.2.3. Using query types</a></span></dt><dt><span class="sect2"><a href="#d0e550">2.2.4. Querying with JDO</a></span></dt><dt><span class="sect2"><a href="#d0e597">2.2.5. General usage</a></span></dt><dt><span class="sect2"><a href="#d0e637">2.2.6. Ordering</a></span></dt><dt><span class="sect2"><a href="#d0e644">2.2.7. Grouping</a></span></dt><dt><span class="sect2"><a href="#d0e651">2.2.8. Delete clauses</a></span></dt><dt><span class="sect2"><a href="#d0e660">2.2.9. Subqueries</a></span></dt><dt><span class="sect2"><a href="#d0e682">2.2.10. Using Native SQL</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sql_integration">2.3. Querying SQL</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e721">2.3.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e730">2.3.2. Code generation via Maven</a></span></dt><dt><span class="sect2"><a href="#d0e1047">2.3.3. Code generation via ANT</a></span></dt><dt><span class="sect2"><a href="#d0e1059">2.3.4. Creating the query types</a></span></dt><dt><span class="sect2"><a href="#d0e1072">2.3.5. Configuration</a></span></dt><dt><span class="sect2"><a href="#d0e1133">2.3.6. Querying</a></span></dt><dt><span class="sect2"><a href="#d0e1160">2.3.7. General usage</a></span></dt><dt><span class="sect2"><a href="#d0e1205">2.3.8. Joins</a></span></dt><dt><span class="sect2"><a href="#d0e1220">2.3.9. Ordering</a></span></dt><dt><span class="sect2"><a href="#d0e1231">2.3.10. Grouping</a></span></dt><dt><span class="sect2"><a href="#d0e1243">2.3.11. Using Subqueries</a></span></dt><dt><span class="sect2"><a href="#d0e1257">2.3.12. Selecting literals</a></span></dt><dt><span class="sect2"><a href="#d0e1269">2.3.13. Query extension support</a></span></dt><dt><span class="sect2"><a href="#d0e1281">2.3.14. Window functions</a></span></dt><dt><span class="sect2"><a href="#d0e1293">2.3.15. Common table expressions</a></span></dt><dt><span class="sect2"><a href="#d0e1310">2.3.16. Other SQL expressions</a></span></dt><dt><span class="sect2"><a href="#d0e1318">2.3.17. Using Data manipulation commands</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e1321">2.3.17.1. Insert</a></span></dt><dt><span class="sect3"><a href="#d0e1366">2.3.17.2. Update</a></span></dt><dt><span class="sect3"><a href="#d0e1381">2.3.17.3. Delete</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e1392">2.3.18. Batch support in DML clauses</a></span></dt><dt><span class="sect2"><a href="#d0e1409">2.3.19. Bean class generation</a></span></dt><dt><span class="sect2"><a href="#d0e1421">2.3.20. Extracting the SQL query and bindings</a></span></dt><dt><span class="sect2"><a href="#d0e1430">2.3.21. Custom types</a></span></dt><dt><span class="sect2"><a href="#d0e1447">2.3.22. Listening to queries and clauses</a></span></dt><dt><span class="sect2"><a href="#d0e1454">2.3.23. Spring integration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#spatial">2.4. Querydsl Spatial</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1476">2.4.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e1487">2.4.2. Code generation via Maven</a></span></dt><dt><span class="sect2"><a href="#d0e1494">2.4.3. Runtime configuration</a></span></dt><dt><span class="sect2"><a href="#d0e1518">2.4.4. Querying</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e1523">2.4.4.1. Filter by Distance</a></span></dt><dt><span class="sect3"><a href="#d0e1530">2.4.4.2. Contains</a></span></dt><dt><span class="sect3"><a href="#d0e1535">2.4.4.3. Intersection</a></span></dt><dt><span class="sect3"><a href="#d0e1540">2.4.4.4. Access to the SPATIAL_REF_SYS table</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e1547">2.4.5. Inheritance</a></span></dt></dl></dd><dt><span class="sect1"><a href="#lucene_integration">2.5. Querying Lucene</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1559">2.5.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e1576">2.5.2. Creating the query types</a></span></dt><dt><span class="sect2"><a href="#d0e1587">2.5.3. Querying</a></span></dt><dt><span class="sect2"><a href="#d0e1598">2.5.4. General usage</a></span></dt><dt><span class="sect2"><a href="#d0e1630">2.5.5. Ordering</a></span></dt><dt><span class="sect2"><a href="#d0e1647">2.5.6. Limit</a></span></dt><dt><span class="sect2"><a href="#d0e1654">2.5.7. Offset</a></span></dt><dt><span class="sect2"><a href="#d0e1661">2.5.8. Fuzzy searches</a></span></dt><dt><span class="sect2"><a href="#d0e1671">2.5.9. Applying Lucene filters to queries</a></span></dt></dl></dd><dt><span class="sect1"><a href="#hibernate_search_integration">2.6. Querying Hibernate Search</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1687">2.6.1. Creating the Querydsl query types</a></span></dt><dt><span class="sect2"><a href="#d0e1695">2.6.2. Querying</a></span></dt><dt><span class="sect2"><a href="#d0e1702">2.6.3. General usage</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mongodb_integration">2.7. Querying Mongodb</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1720">2.7.1. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e1742">2.7.2. Querying</a></span></dt><dt><span class="sect2"><a href="#d0e1749">2.7.3. General usage</a></span></dt><dt><span class="sect2"><a href="#d0e1781">2.7.4. Ordering</a></span></dt><dt><span class="sect2"><a href="#d0e1790">2.7.5. Limit</a></span></dt><dt><span class="sect2"><a href="#d0e1797">2.7.6. Offset</a></span></dt><dt><span class="sect2"><a href="#d0e1804">2.7.7. Geospatial queries</a></span></dt><dt><span class="sect2"><a href="#d0e1811">2.7.8. Select only relevant fields</a></span></dt></dl></dd><dt><span class="sect1"><a href="#collections_integration">2.8. Querying Collections</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1825">2.8.1. Usage without generated query types</a></span></dt><dt><span class="sect2"><a href="#d0e1867">2.8.2. Usage with generated query types</a></span></dt><dt><span class="sect2"><a href="#d0e1876">2.8.3. Maven integration</a></span></dt><dt><span class="sect2"><a href="#d0e1890">2.8.4. Ant integration</a></span></dt><dt><span class="sect2"><a href="#d0e1908">2.8.5. Hamcrest matchers</a></span></dt><dt><span class="sect2"><a href="#d0e1924">2.8.6. Usage with the Eclipse Compiler for Java</a></span></dt></dl></dd><dt><span class="sect1"><a href="#scala">2.9. Querying in Scala</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1938">2.9.1. DSL expressions for Scala</a></span></dt><dt><span class="sect2"><a href="#d0e1948">2.9.2. Querying with SQL</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e1961">2.9.2.1. Code generation</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e1970">2.9.3. Querying with other backends</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#general">3. General usage</a></span></dt><dd><dl><dt><span class="sect1"><a href="#creating_queries">3.1. Creating queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2023">3.1.1. Complex predicates</a></span></dt><dt><span class="sect2"><a href="#d0e2043">3.1.2. Dynamic expressions</a></span></dt><dt><span class="sect2"><a href="#d0e2066">3.1.3. Dynamic paths</a></span></dt><dt><span class="sect2"><a href="#d0e2110">3.1.4. Case expressions</a></span></dt><dt><span class="sect2"><a href="#d0e2126">3.1.5. Casting expressions</a></span></dt><dt><span class="sect2"><a href="#d0e2148">3.1.6. Select literals</a></span></dt></dl></dd><dt><span class="sect1"><a href="#result_handling">3.2. Result handling</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2178">3.2.1. Returning multiple columns</a></span></dt><dt><span class="sect2"><a href="#d0e2192">3.2.2. Bean population</a></span></dt><dt><span class="sect2"><a href="#d0e2203">3.2.3. Constructor usage</a></span></dt><dt><span class="sect2"><a href="#d0e2233">3.2.4. Result aggregation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#codegen">3.3. Code generation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2265">3.3.1. Path initialization</a></span></dt><dt><span class="sect2"><a href="#d0e2281">3.3.2. Customization</a></span></dt><dt><span class="sect2"><a href="#custom_types">3.3.3. Custom type mappings</a></span></dt><dt><span class="sect2"><a href="#d0e2479">3.3.4. Delegate methods</a></span></dt><dt><span class="sect2"><a href="#d0e2502">3.3.5. Non-annotated types</a></span></dt><dt><span class="sect2"><a href="#d0e2517">3.3.6. Classpath based code generation</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e2536">3.3.6.1. Usage via Maven</a></span></dt><dt><span class="sect3"><a href="#d0e2694">3.3.6.2. Scala support</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#alias">3.4. Alias usage</a></span></dt></dl></dd><dt><span class="chapter"><a href="#troubleshooting">4. Troubleshooting</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e2748">4.1. Insufficient type arguments</a></span></dt><dt><span class="sect1"><a href="#d0e2761">4.2. Multithreaded initialization of Querydsl Q-types</a></span></dt><dt><span class="sect1"><a href="#d0e2774">4.3. JDK5 usage</a></span></dt></dl></dd></dl></div><div class="preface" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div></div><p>
    Querydsl is a framework which enables the construction of statically
    typed SQL-like queries. Instead of writing queries as inline strings or externalizing them
    into XML files they can be constructed via a fluent API like Querydsl.
  </p><p>
    The benefits of using a fluent API in comparison to simple strings are for example
  </p><div class="itemizedlist"><ul type="disc"><li><p>code completion in IDE</p></li><li><p>almost none syntactically invalid queries allowed</p></li><li><p>domain types and properties can be referenced safely</p></li><li><p>adopts better to refactoring changes in domain types</p></li></ul></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a name="intro"></a>1.&nbsp;Introduction</h2></div></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e87"></a>1.1.&nbsp;Background</h2></div></div></div><p>
      Querydsl was born out of the need to maintain HQL queries in a typesafe way.       
      Incremental construction of HQL queries requires String concatenation and results
      in hard to read code. Unsafe references to domain types and properties
      via plain Strings were another issue with String based HQL construction.
    </p><p>
      With a changing domain model type-safety brings huge benefits in software
      development. Domain changes are directly reflected in queries and autocomplete in
      query construction makes query construction faster and safer.
    </p><p>
      HQL for Hibernate was the first target language for Querydsl, but nowadays it
      supports JPA, JDO, JDBC, Lucene, Hibernate Search, MongoDB, Collections and RDFBean
      as backends.
    </p><p>
      If you are completely new to database access in Java,<a class="ulink" href="https://www.marcobehler.com/guides/a-guide-to-accessing-databases-in-java" target="_top">https://www.marcobehler.com/guides/a-guide-to-accessing-databases-in-java</a> contains a good overview of the various parts, pieces and options and shows you where exactly QueryDSL fits in.
    </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e101"></a>1.2.&nbsp;Principles</h2></div></div></div><p>
      <span class="emphasis"><em>Type safety</em></span>
      is the core principle of Querydsl. Queries are constructed based on generated query
      types that reflect the properties of your domain types. Also function/method
      invocations are constructed in a fully type-safe manner.
    </p><p>
      <span class="emphasis"><em>Consistency</em></span>
      is another important principle. The query paths and operations are the same
      in all implementations and also the Query interfaces have a common base interface.
    </p><p>
      To get an impression of the expressivity of the Querydsl query and expression types go to
      the javadocs and explore <code class="code">com.querydsl.core.Query</code>, <code class="code">com.querydsl.core.Fetchable</code>
      and <code class="code">com.querydsl.core.types.Expression</code>.
    </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a name="tutorials"></a>2.&nbsp;Tutorials</h2></div></div></div><p>
    Instead of a general Getting started guide we provide integration
    guides for the main backends of Querydsl.
    </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jpa_integration"></a>2.1.&nbsp;Querying JPA</h2></div></div></div><p>
    Querydsl defines a general statically typed syntax for querying on top of
    persisted domain model data. JDO and JPA are the primary integration
    technologies for Querydsl. This guide describes how to use Querydsl
    in combination with JPA.
  </p><p>
    Querydsl for JPA is an alternative to both JPQL and Criteria queries. It combines the
    dynamic nature of Criteria queries with the expressiveness of JPQL and all that in a fully
    typesafe manner.
  </p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e137"></a>2.1.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-apt<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
  <span class="hl-tag">&lt;scope&gt;</span>provided<span class="hl-tag">&lt;/scope&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-jpa<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>slf4j-log4j12<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>1.6.1<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre><p>
      And now, configure the Maven APT plugin:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
  <span class="hl-tag">&lt;plugins&gt;</span>
    ...
    <span class="hl-tag">&lt;plugin&gt;</span>
      <span class="hl-tag">&lt;groupId&gt;</span>com.mysema.maven<span class="hl-tag">&lt;/groupId&gt;</span>
      <span class="hl-tag">&lt;artifactId&gt;</span>apt-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
      <span class="hl-tag">&lt;version&gt;</span>1.1.3<span class="hl-tag">&lt;/version&gt;</span>
      <span class="hl-tag">&lt;executions&gt;</span>
        <span class="hl-tag">&lt;execution&gt;</span>
          <span class="hl-tag">&lt;goals&gt;</span>
            <span class="hl-tag">&lt;goal&gt;</span>process<span class="hl-tag">&lt;/goal&gt;</span>
          <span class="hl-tag">&lt;/goals&gt;</span>
          <span class="hl-tag">&lt;configuration&gt;</span>
            <span class="hl-tag">&lt;outputDirectory&gt;</span>target/generated-sources/java<span class="hl-tag">&lt;/outputDirectory&gt;</span>
            <span class="hl-tag">&lt;processor&gt;</span>com.querydsl.apt.jpa.JPAAnnotationProcessor<span class="hl-tag">&lt;/processor&gt;</span>
          <span class="hl-tag">&lt;/configuration&gt;</span>
        <span class="hl-tag">&lt;/execution&gt;</span>
      <span class="hl-tag">&lt;/executions&gt;</span>
    <span class="hl-tag">&lt;/plugin&gt;</span>
    ...
  <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>
      The JPAAnnotationProcessor finds domain types annotated with the
      javax.persistence.Entity annotation and generates query types for them.
    </p><p>
      If you use Hibernate annotations in your domain types you should use
      the APT processor
      <code class="code">com.querydsl.apt.hibernate.HibernateAnnotationProcessor</code>
      instead.
    </p><p>
      Run clean install and you will get your Query types generated into
      target/generated-sources/java.
    </p><p>
      If you use Eclipse, run mvn eclipse:eclipse to update your Eclipse project to
      include target/generated-sources/java as a source folder.
    </p><p>
      Now you are able to construct JPA query instances and instances of
      the query domain model.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e161"></a>2.1.2.&nbsp;Ant integration</h3></div></div></div><p>Place the jar files from the full-deps bundle on your classpath and use the
      following tasks for Querydsl code generation:
    </p><pre class="programlisting">
    <span class="hl-comment">&lt;!-- APT based code generation --&gt;</span>
    <span class="hl-tag">&lt;javac</span> <span class="hl-attribute">srcdir</span>=<span class="hl-value">"${src}"</span> <span class="hl-attribute">classpathref</span>=<span class="hl-value">"cp"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"-proc:only"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"-processor"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"com.querydsl.apt.jpa.JPAAnnotationProcessor"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"-s"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${generated}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/javac&gt;</span>

    <span class="hl-comment">&lt;!-- compilation --&gt;</span>
    <span class="hl-tag">&lt;javac</span> <span class="hl-attribute">classpathref</span>=<span class="hl-value">"cp"</span> <span class="hl-attribute">destdir</span>=<span class="hl-value">"${build}"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;src</span> <span class="hl-attribute">path</span>=<span class="hl-value">"${src}"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;src</span> <span class="hl-attribute">path</span>=<span class="hl-value">"${generated}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/javac&gt;</span>
</pre><p>
      Replace
      <span class="emphasis"><em>src</em></span>
      with your main source folder,
      <span class="emphasis"><em>generated</em></span>
      with your folder for generated sources
      and
      <span class="emphasis"><em>build</em></span>
      with your target folder.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e179"></a>2.1.3.&nbsp;Using Querydsl JPA in Roo</h3></div></div></div><p>
      If you are using Querydsl JPA with Spring Roo you can replace
      <code class="code">com.querydsl.apt.jpa.JPAAnnotationProcessor</code>
      with
      <code class="code">com.querydsl.apt.roo.RooAnnotationProcessor</code>
      which will handle
      <code class="code">@RooJpaEntity</code> and <code class="code">@RooJpaActiveRecord</code>
      annotated classes instead of
      <code class="code">@Entity</code>
      annotated classes.
    </p><p>
      APT based code generation doesn't work well with AspectJ IDTs.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e201"></a>2.1.4.&nbsp;Generating the model from hbm.xml files</h3></div></div></div><p>If you are using Hibernate with an XML based configuration, you can use the XML
      metadata to create your Querydsl model.
    </p><p><code class="code">com.querydsl.jpa.codegen.HibernateDomainExporter</code> provides the
      functionality for this:</p><pre class="programlisting">
HibernateDomainExporter exporter = <span class="hl-keyword">new</span> HibernateDomainExporter(
  <span class="hl-string">"Q"</span>,                     <span class="hl-comment">// name prefix</span>
  <span class="hl-keyword">new</span> File(<span class="hl-string">"target/gen3"</span>), <span class="hl-comment">// target folder</span>
  configuration);          <span class="hl-comment">// instance of org.hibernate.cfg.Configuration</span>

exporter.export();
</pre><p>The HibernateDomainExporter needs to be executed within a classpath where the
      domain types are visible, since the property types are resolved
      via reflection.
    </p><p>All JPA annotations are ignored, but Querydsl annotations such as @QueryInit and
      @QueryType are taken into account.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e216"></a>2.1.5.&nbsp;Using query types</h3></div></div></div><p>
      To create queries with Querydsl you need to instantiate variables and
      Query implementations. We will start with the variables.
    </p><p>
      Let's assume that your project has the following domain type:
    </p><pre class="programlisting">
<span class="hl-annotation">@Entity</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Customer {
    <span class="hl-keyword">private</span> String firstName;
    <span class="hl-keyword">private</span> String lastName;

    <span class="hl-keyword">public</span> String getFirstName() {
        <span class="hl-keyword">return</span> firstName;
    }

    <span class="hl-keyword">public</span> String getLastName() {
        <span class="hl-keyword">return</span> lastName;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFirstName(String fn) {
        firstName = fn;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setLastName(String ln) {
        lastName = ln;
    }
}
</pre><p>
      Querydsl will generate a query type with the simple name QCustomer into the
      same package as Customer. QCustomer can be used as a statically
      typed variable in Querydsl queries as a representative for the
      Customer type.
    </p><p>
      QCustomer has a default instance variable which can be accessed as a static
      field:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
</pre><p>
      Alternatively you can define your own Customer variables like this:
    </p><pre class="programlisting">
QCustomer customer = <span class="hl-keyword">new</span> QCustomer(<span class="hl-string">"myCustomer"</span>);
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e235"></a>2.1.6.&nbsp;Querying</h3></div></div></div><p>The Querydsl JPA module supports both the JPA and the Hibernate API.</p><p>
      To use the JPA API you use <code class="code">JPAQuery</code> instances for your queries like
      this:
    </p><pre class="programlisting">
<span class="hl-comment">// where entityManager is a JPA EntityManager</span>
JPAQuery&lt;?&gt; query = <span class="hl-keyword">new</span> JPAQuery&lt;Void&gt;(entityManager);
</pre><p>If you are using the Hibernate API instead, you can instantiate a
    <code class="code">HibernateQuery</code> like this:
    </p><pre class="programlisting">
<span class="hl-comment">// where session is a Hibernate session</span>
HibernateQuery&lt;?&gt; query = <span class="hl-keyword">new</span> HibernateQuery&lt;Void&gt;(session);
</pre><p>Both <code class="code">JPAQuery</code> and <code class="code">HibernateQuery</code> implement the <code class="code">JPQLQuery</code> interface.</p><p>For the examples of this chapter the queries are created via a <code class="code">JPAQueryFactory</code> instance.
      <code class="code">JPAQueryFactory</code> should be the preferred option to obtain <code class="code">JPAQuery</code> instances.</p><p>For the Hibernate API <code class="code">HibernateQueryFactory</code> can be used</p><p>
      To retrieve the customer with the first name Bob you would construct a
      query like this:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
Customer bob = queryFactory.selectFrom(customer)
  .where(customer.firstName.eq(<span class="hl-string">"Bob"</span>))
  .fetchOne();
</pre><p>
      The selectFrom call defines the query source and projection, the where part defines the
      filter and fetchOne tells Querydsl to return a single element. Easy, right?
    </p><p>
      To create a query with multiple sources you use the query like this:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
QCompany company = QCompany.company;
query.from(customer, company);
</pre><p>
      And to use multiple filters use it like this
    </p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<span class="hl-string">"Bob"</span>), customer.lastName.eq(<span class="hl-string">"Wilson"</span>));
</pre><p>Or like this</p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<span class="hl-string">"Bob"</span>).and(customer.lastName.eq(<span class="hl-string">"Wilson"</span>)));
</pre><p>In native JPQL form the query would be written like this: </p><pre class="programlisting">
select customer from Customer as customer
where customer.firstName = "Bob" and customer.lastName = "Wilson"
</pre><p>If you want to combine the filters via "or" then use the following pattern
    </p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<span class="hl-string">"Bob"</span>).or(customer.lastName.eq(<span class="hl-string">"Wilson"</span>)));
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e307"></a>2.1.7.&nbsp;Using joins</h3></div></div></div><p>Querydsl supports the following join variants in JPQL: inner join, join, left
      join and right join. Join usage is typesafe, and follows the following pattern:
    </p><pre class="programlisting">
QCat cat = QCat.cat;
QCat mate = <span class="hl-keyword">new</span> QCat(<span class="hl-string">"mate"</span>);
QCat kitten = <span class="hl-keyword">new</span> QCat(<span class="hl-string">"kitten"</span>);
queryFactory.selectFrom(cat)
    .innerJoin(cat.mate, mate)
    .leftJoin(cat.kittens, kitten)
    .fetch();
</pre><p>The native JPQL version of the query would be </p><pre class="programlisting">
select cat from Cat as cat
inner join cat.mate as mate
left outer join cat.kittens as kitten
</pre><p>Another example</p><pre class="programlisting">
queryFactory.selectFrom(cat)
    .leftJoin(cat.kittens, kitten)
    .on(kitten.bodyWeight.gt(<span class="hl-value">10.0</span>))
    .fetch();
</pre><p>With the following JPQL version</p><pre class="programlisting">
select cat from Cat as cat
left join cat.kittens as kitten
on kitten.bodyWeight &gt; 10.0
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e326"></a>2.1.8.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the JPQLQuery interface like this</p><p>
      <span class="emphasis"><em>select:</em></span>
      Set the projection of the query. (Not necessary if created via query factory)
    </p><p>
      <span class="emphasis"><em>from:</em></span>
      Add the query sources here.
    </p><p>
      <span class="emphasis"><em>innerJoin, join, leftJoin, rightJoin, on:</em></span>
      Add join elements using these constructs.
      For the join methods the first argument is the join source and the second the target
      (alias).
    </p><p>
      <span class="emphasis"><em>where:</em></span>
      Add query filters, either in varargs form separated via commas or
      cascaded via the and-operator.
    </p><p>
      <span class="emphasis"><em>groupBy:</em></span>
      Add group by arguments in varargs form.
    </p><p>
      <span class="emphasis"><em>having:</em></span>
      Add having filters of the "group by" grouping as an varags array of
      Predicate expressions.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e371"></a>2.1.9.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
queryFactory.selectFrom(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.desc())
    .fetch();
</pre><p>which is equivalent to the following native JPQL</p><pre class="programlisting">
select customer from Customer as customer
order by customer.lastName asc, customer.firstName desc
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e382"></a>2.1.10.&nbsp;Grouping</h3></div></div></div><p>Grouping can be done in the following form</p><pre class="programlisting">
queryFactory.select(customer.lastName).from(customer)
    .groupBy(customer.lastName)
    .fetch();
</pre><p>which is equivalent to the following native JPQL</p><pre class="programlisting">
select customer.lastName
from Customer as customer
group by customer.lastName
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e393"></a>2.1.11.&nbsp;Delete clauses</h3></div></div></div><p>Delete clauses in Querydsl JPA follow a simple delete-where-execute form. Here
      are some
      examples:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
<span class="hl-comment">// delete all customers</span>
queryFactory.delete(customer).execute();
<span class="hl-comment">// delete all customers with a level less than 3</span>
queryFactory.delete(customer).where(customer.level.lt(<span class="hl-value">3</span>)).execute();
</pre><p>The where call is optional and the execute call performs the deletion and returns the
      amount of deleted entities.
    </p><p>DML clauses in JPA don't take JPA level cascade rules into account and don't provide
    fine-grained second level cache interaction.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e404"></a>2.1.12.&nbsp;Update clauses</h3></div></div></div><p>Update clauses in Querydsl JPA follow a simple update-set/where-execute form.
      Here are some examples:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
<span class="hl-comment">// rename customers named Bob to Bobby</span>
queryFactory.update(customer).where(customer.name.eq(<span class="hl-string">"Bob"</span>))
    .set(customer.name, <span class="hl-string">"Bobby"</span>)
    .execute();
</pre><p>The set invocations define the property updates in SQL-Update-style and the execute call
      performs the Update and returns the amount of updated entities.
    </p><p>DML clauses in JPA don't take JPA level cascade rules into account and don't provide
    fine-grained second level cache interaction.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e415"></a>2.1.13.&nbsp;Subqueries</h3></div></div></div><p>To create a subquery you use the static factory methods of <code class="code">JPAExpressions</code> and
      define the query parameters via from, where etc.
    </p><pre class="programlisting">
QDepartment department = QDepartment.department;
QDepartment d = <span class="hl-keyword">new</span> QDepartment(<span class="hl-string">"d"</span>);
queryFactory.selectFrom(department)
    .where(department.size.eq(
        JPAExpressions.select(d.size.max()).from(d)))
     .fetch();
</pre><p>Another example</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
QEmployee e = <span class="hl-keyword">new</span> QEmployee(<span class="hl-string">"e"</span>);
queryFactory.selectFrom(employee)
    .where(employee.weeklyhours.gt(
        JPAExpressions.select(e.weeklyhours.avg())
            .from(employee.department.employees, e)
            .where(e.manager.eq(employee.manager))))
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e429"></a>2.1.14.&nbsp;Exposing the original query</h3></div></div></div><p>If you need to tune the original Query before the execution of the query you
      can expose it like this:
    </p><pre class="programlisting">
Query jpaQuery = queryFactory.selectFrom(employee).createQuery();
<span class="hl-comment">// ...</span>
List results = jpaQuery.getResultList();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e436"></a>2.1.15.&nbsp;Using Native SQL in JPA queries</h3></div></div></div><p>Querydsl supports Native SQL in JPA via the JPASQLQuery class.
    </p><p>To use it, you must generate Querydsl query types for your SQL schema. This can
      be done for example with the following Maven configuration:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
    <span class="hl-tag">&lt;plugins&gt;</span>
      ...
      <span class="hl-tag">&lt;plugin&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;executions&gt;</span>
          <span class="hl-tag">&lt;execution&gt;</span>
            <span class="hl-tag">&lt;goals&gt;</span>
              <span class="hl-tag">&lt;goal&gt;</span>export<span class="hl-tag">&lt;/goal&gt;</span>
            <span class="hl-tag">&lt;/goals&gt;</span>
          <span class="hl-tag">&lt;/execution&gt;</span>
        <span class="hl-tag">&lt;/executions&gt;</span>
        <span class="hl-tag">&lt;configuration&gt;</span>
          <span class="hl-tag">&lt;jdbcDriver&gt;</span>org.apache.derby.jdbc.EmbeddedDriver<span class="hl-tag">&lt;/jdbcDriver&gt;</span>
          <span class="hl-tag">&lt;jdbcUrl&gt;</span>jdbc:derby:target/demoDB;create=true<span class="hl-tag">&lt;/jdbcUrl&gt;</span>
          <span class="hl-tag">&lt;packageName&gt;</span>com.mycompany.mydomain<span class="hl-tag">&lt;/packageName&gt;</span>
          <span class="hl-tag">&lt;targetFolder&gt;</span>${project.basedir}/target/generated-sources/java<span class="hl-tag">&lt;/targetFolder&gt;</span>
        <span class="hl-tag">&lt;/configuration&gt;</span>
        <span class="hl-tag">&lt;dependencies&gt;</span>
          <span class="hl-tag">&lt;dependency&gt;</span>
            <span class="hl-tag">&lt;groupId&gt;</span>org.apache.derby<span class="hl-tag">&lt;/groupId&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>derby<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;version&gt;</span>${derby.version}<span class="hl-tag">&lt;/version&gt;</span>
          <span class="hl-tag">&lt;/dependency&gt;</span>
        <span class="hl-tag">&lt;/dependencies&gt;</span>
      <span class="hl-tag">&lt;/plugin&gt;</span>
      ...
    <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>When the query types have successfully been generated into the location of your
      choice, you can use them in your queries.
    </p><p>Single column query:</p><pre class="programlisting">
<span class="hl-comment">// serialization templates</span>
SQLTemplates templates = <span class="hl-keyword">new</span> DerbyTemplates();
<span class="hl-comment">// query types (S* for SQL, Q* for domain types)</span>
SAnimal cat = <span class="hl-keyword">new</span> SAnimal(<span class="hl-string">"cat"</span>);
SAnimal mate = <span class="hl-keyword">new</span> SAnimal(<span class="hl-string">"mate"</span>);
QCat catEntity = QCat.cat;

JPASQLQuery&lt;?&gt; query = <span class="hl-keyword">new</span> JPASQLQuery&lt;Void&gt;(entityManager, templates);
List&lt;String&gt; names = query.select(cat.name).from(cat).fetch();
</pre><p>If you mix entity (e.g. QCat) and table (e.g. SAnimal) references in your query you need to make sure that they
    use the same variable names. SAnimal.animal has the variable name "animal", so a new instance
    (new SAnimal("cat")) was used instead.</p><p>An alternative pattern could be</p><pre class="programlisting">
QCat catEntity = QCat.cat;
SAnimal cat = <span class="hl-keyword">new</span> SAnimal(catEntity.getMetadata().getName());
</pre><p>Query multiple columns:</p><pre class="programlisting">
query = <span class="hl-keyword">new</span> JPASQLQuery&lt;Void&gt;(entityManager, templates);
List&lt;Tuple&gt; rows = query.select(cat.id, cat.name).from(cat).fetch();
</pre><p>Query all columns:</p><pre class="programlisting">
List&lt;Tuple&gt; rows = query.select(cat.all()).from(cat).fetch();
 </pre><p>Query in SQL, but project as entity: </p><pre class="programlisting">
query = <span class="hl-keyword">new</span> JPASQLQuery&lt;Void&gt;(entityManager, templates);
List&lt;Cat&gt; cats = query.select(catEntity).from(cat).orderBy(cat.name.asc()).fetch();
</pre><p>Query with joins: </p><pre class="programlisting">
query = <span class="hl-keyword">new</span> JPASQLQuery&lt;Void&gt;(entityManager, templates);
cats = query.select(catEntity).from(cat)
    .innerJoin(mate).on(cat.mateId.eq(mate.id))
    .where(cat.dtype.eq(<span class="hl-string">"Cat"</span>), mate.dtype.eq(<span class="hl-string">"Cat"</span>))
    .fetch();
</pre><p>Query and project into DTO: </p><pre class="programlisting">
query = <span class="hl-keyword">new</span> JPASQLQuery&lt;Void&gt;(entityManager, templates);
List&lt;CatDTO&gt; catDTOs = query.select(Projections.constructor(CatDTO.<span class="hl-keyword">class</span>, cat.id, cat.name))
    .from(cat)
    .orderBy(cat.name.asc())
    .fetch();
</pre><p>If you are using the Hibernate API instead of the JPA API, then use
      <code class="code">HibernateSQLQuery</code> instead.
    </p></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo_integration"></a>2.2.&nbsp;Querying JDO</h2></div></div></div><p>
    Querydsl defines a general statically typed syntax for querying on top of
    persisted domain model data. JDO and JPA are the primary integration
    technologies for
    Querydsl. This guide describes how to use Querydsl
    in combination with JDO.
  </p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e487"></a>2.2.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-apt<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
  <span class="hl-tag">&lt;scope&gt;</span>provided<span class="hl-tag">&lt;/scope&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-jdo<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>slf4j-log4j12<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>1.6.1<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre><p>
      And now, configure the Maven APT plugin which generates the query types
      used by
      Querydsl:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
    <span class="hl-tag">&lt;plugins&gt;</span>
      ...
      <span class="hl-tag">&lt;plugin&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>com.mysema.maven<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>apt-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>1.1.3<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;executions&gt;</span>
          <span class="hl-tag">&lt;execution&gt;</span>
            <span class="hl-tag">&lt;goals&gt;</span>
              <span class="hl-tag">&lt;goal&gt;</span>process<span class="hl-tag">&lt;/goal&gt;</span>
            <span class="hl-tag">&lt;/goals&gt;</span>
            <span class="hl-tag">&lt;configuration&gt;</span>
              <span class="hl-tag">&lt;outputDirectory&gt;</span>target/generated-sources/java<span class="hl-tag">&lt;/outputDirectory&gt;</span>
              <span class="hl-tag">&lt;processor&gt;</span>com.querydsl.apt.jdo.JDOAnnotationProcessor<span class="hl-tag">&lt;/processor&gt;</span>
            <span class="hl-tag">&lt;/configuration&gt;</span>
          <span class="hl-tag">&lt;/execution&gt;</span>
        <span class="hl-tag">&lt;/executions&gt;</span>
      <span class="hl-tag">&lt;/plugin&gt;</span>
    ...
    <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>
      The JDOAnnotationProcessor finds domain types annotated with the
      <code class="code">javax.jdo.annotations.PersistenceCapable</code> annotation and generates
      query types for them.
    </p><p>
      Run clean install and you will get your query types generated into
      target/generated-sources/java.
    </p><p>
      If you use Eclipse, run mvn eclipse:eclipse to update your Eclipse project to
      include target/generated-sources/java as a source folder.
    </p><p>
      Now you are able to construct JDO query instances and instances of the query domain model.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e509"></a>2.2.2.&nbsp;Ant integration</h3></div></div></div><p>Place the jar files from the full-deps bundle on your classpath and use the
      following tasks for Querydsl code generation:
    </p><pre class="programlisting">
    <span class="hl-comment">&lt;!-- APT based code generation --&gt;</span>
    <span class="hl-tag">&lt;javac</span> <span class="hl-attribute">srcdir</span>=<span class="hl-value">"${src}"</span> <span class="hl-attribute">classpathref</span>=<span class="hl-value">"cp"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"-proc:only"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"-processor"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"com.querydsl.apt.jdo.JDOAnnotationProcessor"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"-s"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${generated}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/javac&gt;</span>

    <span class="hl-comment">&lt;!-- compilation --&gt;</span>
    <span class="hl-tag">&lt;javac</span> <span class="hl-attribute">classpathref</span>=<span class="hl-value">"cp"</span> <span class="hl-attribute">destdir</span>=<span class="hl-value">"${build}"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;src</span> <span class="hl-attribute">path</span>=<span class="hl-value">"${src}"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;src</span> <span class="hl-attribute">path</span>=<span class="hl-value">"${generated}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/javac&gt;</span>
</pre><p>
      Replace
      <span class="emphasis"><em>src</em></span>
      with your main source folder,
      <span class="emphasis"><em>generated</em></span>
      with your folder for generated sources
      and
      <span class="emphasis"><em>build</em></span>
      with your target folder.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e527"></a>2.2.3.&nbsp;Using query types</h3></div></div></div><p>
      To create queries with Querydsl you need to instantiate variables and Query
      implementations. We will start with the variables.
    </p><p>
      Let's assume that your project has the following domain type:
    </p><pre class="programlisting">
<span class="hl-annotation">@PersistenceCapable</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Customer {
  <span class="hl-keyword">private</span> String firstName;
  <span class="hl-keyword">private</span> String lastName;

  <span class="hl-keyword">public</span> String getFirstName() {
    <span class="hl-keyword">return</span> firstName;
  }

  <span class="hl-keyword">public</span> String getLastName() {
    <span class="hl-keyword">return</span> lastName;
  }

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFirstName(String fn) {
    firstName = fn;
  }

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setLastName(String ln) {
    lastName = ln;
  }
}
</pre><p>
      Querydsl will generate a query type with the simple name QCustomer into the
      same package as Customer. QCustomer can be used as a statically
      typed variable in Querydsl as a representative for the
      Customer type.
    </p><p>
      QCustomer has a default instance variable which can be accessed as a static
      field:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
</pre><p>
      Alternatively you can define your own Customer variables like this:
    </p><pre class="programlisting">
QCustomer customer = <span class="hl-keyword">new</span> QCustomer(<span class="hl-string">"myCustomer"</span>);
</pre><p>
      QCustomer reflects all the properties of the original type Customer as public
      fields. The firstName field can be accessed like this
    </p><pre class="programlisting">
customer.firstName;
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e550"></a>2.2.4.&nbsp;Querying with JDO</h3></div></div></div><p>
      For the JDO-module <code class="code">JDOQuery</code> is the main Query implementation. It
      is instantiated like this:
    </p><pre class="programlisting">
PersistenceManager pm = ...;
JDOQuery&lt;?&gt; query = <span class="hl-keyword">new</span> JDOQuery&lt;Void&gt;(pm);
</pre><p>For the examples of this chapter the queries are created via a <code class="code">JDOQueryFactory</code> instance.
    <code class="code">JDOQueryFactory</code> should be the preferred option to obtain <code class="code">JDOQuery</code> instances.</p><p>
      To retrieve the customer with the first name Bob you would construct a
      query like this:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
Customer bob = queryFactory.selectFrom(customer)
                   .where(customer.firstName.eq(<span class="hl-string">"Bob"</span>))
                   .fetchOne();
</pre><p>
      The selectFrom call defines the query source and projection, the where part defines the
      filter and fetchOne tells Querydsl to return a single element. Easy, right?
    </p><p>Alternatively you can express it also like this</p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
Customer bob = queryFactory.select(customer).from(customer)
                   .where(customer.firstName.eq(<span class="hl-string">"Bob"</span>))
                   .fetchOne();
</pre><p>
      To create a query with multiple sources you just use the JDOQuery class like this:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
QCompany company = QCompany.company;
query.from(customer, company);
</pre><p>
      And to use multiple filters use it like this
    </p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<span class="hl-string">"Bob"</span>), customer.lastName.eq(<span class="hl-string">"Wilson"</span>));
</pre><p>Or like this</p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<span class="hl-string">"Bob"</span>).and(customer.lastName.eq(<span class="hl-string">"Wilson"</span>)));
</pre><p>If you want to combine the filters via "or" then use the following pattern
    </p><pre class="programlisting">
queryFactory.selectFrom(customer)
    .where(customer.firstName.eq(<span class="hl-string">"Bob"</span>).or(customer.lastName.eq(<span class="hl-string">"Wilson"</span>)));
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e597"></a>2.2.5.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the JDOQuery class like this</p><p>
      <span class="emphasis"><em>select:</em></span>
      Set the projection of the query. (Not necessary if created via query factory)
    </p><p>
      <span class="emphasis"><em>from:</em></span>
      Add query sources here, the first argument becomes the main source
      and the others are treated as variables.
    </p><p>
      <span class="emphasis"><em>where:</em></span>
      Add query filters, either in varargs form separated via commas or
      cascaded via the and-operator.
    </p><p>
      <span class="emphasis"><em>groupBy:</em></span>
      Add group by arguments in varargs form.
    </p><p>
      <span class="emphasis"><em>having:</em></span>
      Add having filters of the "group by" grouping as an varargs array of
      Predicate expressions.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e637"></a>2.2.6.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
queryFactory.selectFrom(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.desc())
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e644"></a>2.2.7.&nbsp;Grouping</h3></div></div></div><p>Grouping can be done in the following form</p><pre class="programlisting">
queryFactory.select(customer.lastName).from(customer)
    .groupBy(customer.lastName)
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e651"></a>2.2.8.&nbsp;Delete clauses</h3></div></div></div><p>Delete clauses in Querydsl JDO follow a simple delete-where-execute form. Here
      are some examples:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
<span class="hl-comment">// delete all customers</span>
queryFactory.delete(customer).execute();
<span class="hl-comment">// delete all customers with a level less than 3</span>
queryFactory.delete(customer).where(customer.level.lt(<span class="hl-value">3</span>)).execute();
</pre><p>The second parameter of the JDODeleteClause constructor is the entity to be
      deleted. The where call is optional and the execute call performs the deletion and
      returns the amount of deleted entities.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e660"></a>2.2.9.&nbsp;Subqueries</h3></div></div></div><p>To create a subquery you can use one of the factory methods of <code class="code">JDOExpressions</code>
      and add the query parameters via from, where etc.
    </p><pre class="programlisting">
QDepartment department = QDepartment.department;
QDepartment d = <span class="hl-keyword">new</span> QDepartment(<span class="hl-string">"d"</span>);
queryFactory.selectFrom(department)
    .where(department.size.eq(JDOExpressions.select(d.size.max()).from(d))
    .fetch();
</pre><p>represents the following native JDO query</p><pre class="programlisting">
SELECT this FROM com.querydsl.jdo.models.company.Department
WHERE this.size ==
(SELECT max(d.size) FROM com.querydsl.jdo.models.company.Department d)
    </pre><p>Another example</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
QEmployee e = <span class="hl-keyword">new</span> QEmployee(<span class="hl-string">"e"</span>);
queryFactory.selectFrom(employee)
    .where(employee.weeklyhours.gt(
        JDOExpressions.select(e.weeklyhours.avg())
                      .from(employee.department.employees, e)
                      .where(e.manager.eq(employee.manager)))
    .fetch();
</pre><p>which represents the following native JDO query</p><pre class="programlisting">
SELECT this FROM com.querydsl.jdo.models.company.Employee
WHERE this.weeklyhours &gt;
(SELECT avg(e.weeklyhours) FROM this.department.employees e WHERE e.manager == this.manager)
    </pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e682"></a>2.2.10.&nbsp;Using Native SQL</h3></div></div></div><p>Querydsl supports Native SQL in JDO via the <code class="code">JDOSQLQuery</code> class.</p><p>To use it, you must generate Querydsl query types for your SQL schema. This can
      be done for example with the following Maven configuration:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
    <span class="hl-tag">&lt;plugins&gt;</span>
      ...
      <span class="hl-tag">&lt;plugin&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;executions&gt;</span>
          <span class="hl-tag">&lt;execution&gt;</span>
            <span class="hl-tag">&lt;goals&gt;</span>
              <span class="hl-tag">&lt;goal&gt;</span>export<span class="hl-tag">&lt;/goal&gt;</span>
            <span class="hl-tag">&lt;/goals&gt;</span>
          <span class="hl-tag">&lt;/execution&gt;</span>
        <span class="hl-tag">&lt;/executions&gt;</span>
        <span class="hl-tag">&lt;configuration&gt;</span>
          <span class="hl-tag">&lt;jdbcDriver&gt;</span>org.apache.derby.jdbc.EmbeddedDriver<span class="hl-tag">&lt;/jdbcDriver&gt;</span>
          <span class="hl-tag">&lt;jdbcUrl&gt;</span>jdbc:derby:target/demoDB;create=true<span class="hl-tag">&lt;/jdbcUrl&gt;</span>
          <span class="hl-tag">&lt;packageName&gt;</span>com.mycompany.mydomain<span class="hl-tag">&lt;/packageName&gt;</span>
          <span class="hl-tag">&lt;targetFolder&gt;</span>${project.basedir}/target/generated-sources/java<span class="hl-tag">&lt;/targetFolder&gt;</span>
        <span class="hl-tag">&lt;/configuration&gt;</span>
        <span class="hl-tag">&lt;dependencies&gt;</span>
          <span class="hl-tag">&lt;dependency&gt;</span>
            <span class="hl-tag">&lt;groupId&gt;</span>org.apache.derby<span class="hl-tag">&lt;/groupId&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>derby<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;version&gt;</span>${derby.version}<span class="hl-tag">&lt;/version&gt;</span>
          <span class="hl-tag">&lt;/dependency&gt;</span>
        <span class="hl-tag">&lt;/dependencies&gt;</span>
      <span class="hl-tag">&lt;/plugin&gt;</span>
      ...
    <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>When the query types have successfully been generated into the location of your
      choice, you can use them in your queries.
    </p><p>Single column query:</p><pre class="programlisting">
<span class="hl-comment">// serialization templates</span>
SQLTemplates templates = <span class="hl-keyword">new</span> DerbyTemplates();
<span class="hl-comment">// query types (S* for SQL, Q* for domain types)</span>
SAnimal cat = <span class="hl-keyword">new</span> SAnimal(<span class="hl-string">"cat"</span>);
SAnimal mate = <span class="hl-keyword">new</span> SAnimal(<span class="hl-string">"mate"</span>);

JDOSQLQuery&lt;?&gt; query = <span class="hl-keyword">new</span> JDOSQLQuery&lt;Void&gt;(pm, templates);
List&lt;String&gt; names = query.select(cat.name).from(cat).fetch();
</pre><p>Query multiple columns:</p><pre class="programlisting">
query = <span class="hl-keyword">new</span> JDOSQLQuery&lt;Void&gt;(pm, templates);
List&lt;Tuple&gt; rows = query.select(cat.id, cat.name).from(cat).fetch();
</pre><p>Query all columns:</p><pre class="programlisting">
List&lt;Tuple&gt; rows = query.select(cat.all()).from(cat).fetch();
 </pre><p>Query with joins: </p><pre class="programlisting">
query = <span class="hl-keyword">new</span> JDOSQLQuery&lt;Void&gt;(pm, templates);
cats = query.select(catEntity).from(cat)
    .innerJoin(mate).on(cat.mateId.eq(mate.id))
    .where(cat.dtype.eq(<span class="hl-string">"Cat"</span>), mate.dtype.eq(<span class="hl-string">"Cat"</span>))
    .fetch();
</pre><p>Query and project into DTO: </p><pre class="programlisting">
query = <span class="hl-keyword">new</span> JDOSQLQuery&lt;Void&gt;(pm, templates);
List&lt;CatDTO&gt; catDTOs = query.select(Projections.constructor(CatDTO.<span class="hl-keyword">class</span>, cat.id, cat.name))
    .from(cat)
    .orderBy(cat.name.asc())
    .fetch();
</pre></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql_integration"></a>2.3.&nbsp;Querying SQL</h2></div></div></div><p>This chapter describes the query type generation and querying functionality of the
    SQL module.</p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e721"></a>2.3.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-sql<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-sql-codegen<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
  <span class="hl-tag">&lt;scope&gt;</span>provided<span class="hl-tag">&lt;/scope&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>slf4j-log4j12<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>1.6.1<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre><p>The querydsl-sql-codegen dependency can be skipped, if code generation happens
      via Maven.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e730"></a>2.3.2.&nbsp;Code generation via Maven</h3></div></div></div><p>This functionality should be primarily used via the Maven plugin. Here is an example:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
    <span class="hl-tag">&lt;plugins&gt;</span>
      ...
      <span class="hl-tag">&lt;plugin&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;executions&gt;</span>
          <span class="hl-tag">&lt;execution&gt;</span>
            <span class="hl-tag">&lt;goals&gt;</span>
              <span class="hl-tag">&lt;goal&gt;</span>export<span class="hl-tag">&lt;/goal&gt;</span>
            <span class="hl-tag">&lt;/goals&gt;</span>
          <span class="hl-tag">&lt;/execution&gt;</span>
        <span class="hl-tag">&lt;/executions&gt;</span>
        <span class="hl-tag">&lt;configuration&gt;</span>
          <span class="hl-tag">&lt;jdbcDriver&gt;</span>org.apache.derby.jdbc.EmbeddedDriver<span class="hl-tag">&lt;/jdbcDriver&gt;</span>
          <span class="hl-tag">&lt;jdbcUrl&gt;</span>jdbc:derby:target/demoDB;create=true<span class="hl-tag">&lt;/jdbcUrl&gt;</span>
          <span class="hl-tag">&lt;packageName&gt;</span>com.myproject.domain<span class="hl-tag">&lt;/packageName&gt;</span>
          <span class="hl-tag">&lt;targetFolder&gt;</span>${project.basedir}/target/generated-sources/java<span class="hl-tag">&lt;/targetFolder&gt;</span>
        <span class="hl-tag">&lt;/configuration&gt;</span>
        <span class="hl-tag">&lt;dependencies&gt;</span>
          <span class="hl-tag">&lt;dependency&gt;</span>
            <span class="hl-tag">&lt;groupId&gt;</span>org.apache.derby<span class="hl-tag">&lt;/groupId&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>derby<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;version&gt;</span>${derby.version}<span class="hl-tag">&lt;/version&gt;</span>
          <span class="hl-tag">&lt;/dependency&gt;</span>
        <span class="hl-tag">&lt;/dependencies&gt;</span>
      <span class="hl-tag">&lt;/plugin&gt;</span>
      ...
    <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>
      Use the goal <span class="emphasis"><em>test-export</em></span>
      to treat the target folder as a test source folder for use with test code.
    </p><div class="table"><a name="d0e742"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Parameters</b></p><div class="table-contents"><table summary="Parameters" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Name</th><th style="border-bottom: 0.5pt solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">jdbcDriver</td><td style="border-bottom: 0.5pt solid ; " align="left">class name of the JDBC driver</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">jdbcUrl</td><td style="border-bottom: 0.5pt solid ; " align="left">JDBC url</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">jdbcUser</td><td style="border-bottom: 0.5pt solid ; " align="left">JDBC user</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">jdbcPassword</td><td style="border-bottom: 0.5pt solid ; " align="left">JDBC password</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">namePrefix</td><td style="border-bottom: 0.5pt solid ; " align="left">name prefix for generated query classes (default: Q)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">nameSuffix</td><td style="border-bottom: 0.5pt solid ; " align="left">name suffix for generated query classes (default: )</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">beanPrefix</td><td style="border-bottom: 0.5pt solid ; " align="left">name prefix for generated bean classes</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">beanSuffix</td><td style="border-bottom: 0.5pt solid ; " align="left">name suffix for generated bean classes</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">packageName</td><td style="border-bottom: 0.5pt solid ; " align="left">package name where source files should be generated</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">beanPackageName</td><td style="border-bottom: 0.5pt solid ; " align="left">package name where bean files should be generated, (default:
              packageName)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">beanInterfaces</td><td style="border-bottom: 0.5pt solid ; " align="left">array of interface classnames to add to the bean classes (default: empty)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">beanAddToString</td><td style="border-bottom: 0.5pt solid ; " align="left">set to true to create a default toString() implementation (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">beanAddFullConstructor</td><td style="border-bottom: 0.5pt solid ; " align="left">set to true to create a full constructor in addition to public empty (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">beanPrintSupertype</td><td style="border-bottom: 0.5pt solid ; " align="left">set to true to print the supertype as well (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">schemaPattern</td><td style="border-bottom: 0.5pt solid ; " align="left">a schema name pattern in LIKE pattern form; must match the schema name as it is stored in the database,
              multiple can be separated by comma
              (default: null)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">tableNamePattern</td><td style="border-bottom: 0.5pt solid ; " align="left">a table name pattern in LIKE pattern form; must match the table name as it is stored in the database,
              multiple can be separated by comma
              (default: null)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">targetFolder</td><td style="border-bottom: 0.5pt solid ; " align="left">target folder where sources should be generated</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">beansTargetFolder</td><td style="border-bottom: 0.5pt solid ; " align="left">target folder where bean sources should be generated, defaults to the same value as targetFolder</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">namingStrategyClass</td><td style="border-bottom: 0.5pt solid ; " align="left">class name of the NamingStrategy class (default: DefaultNamingStrategy)
            </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">beanSerializerClass</td><td style="border-bottom: 0.5pt solid ; " align="left">class name of the BeanSerializer class (default: BeanSerializer)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">serializerClass</td><td style="border-bottom: 0.5pt solid ; " align="left">class name of the Serializer class (default: MetaDataSerializer)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">exportBeans</td><td style="border-bottom: 0.5pt solid ; " align="left">set to true to generate beans as well, see section 2.14.13 (default:
              false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">innerClassesForKeys</td><td style="border-bottom: 0.5pt solid ; " align="left">set to true to generate inner classes for keys (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">validationAnnotations</td><td style="border-bottom: 0.5pt solid ; " align="left">set to true to enable serialization of validation annotations
              (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">columnAnnotations</td><td style="border-bottom: 0.5pt solid ; " align="left">export column annotations (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">createScalaSources</td><td style="border-bottom: 0.5pt solid ; " align="left">whether to export Scala sources instead of Java sources, (default:
              false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">schemaToPackage</td><td style="border-bottom: 0.5pt solid ; " align="left">append schema name to package (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">lowerCase</td><td style="border-bottom: 0.5pt solid ; " align="left">lower case transformation of names (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">exportTables</td><td style="border-bottom: 0.5pt solid ; " align="left">export tables (default: true)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">exportViews</td><td style="border-bottom: 0.5pt solid ; " align="left">export views (default: true)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">exportPrimaryKeys</td><td style="border-bottom: 0.5pt solid ; " align="left">export primary keys (default: true)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">tableTypesToExport</td><td style="border-bottom: 0.5pt solid ; " align="left">Comma-separated list of table types to export (allowable values will depend on JDBC driver).  Allows for arbitrary set of types to be exported, e.g.: "TABLE, MATERIALIZED VIEW". The exportTables and exportViews parameters will be ignored if this parameter is set. (default: none)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">exportForeignKeys</td><td style="border-bottom: 0.5pt solid ; " align="left">export foreign keys (default: true)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">exportDirectForeignKeys</td><td style="border-bottom: 0.5pt solid ; " align="left">export direct foreign keys (default: true)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">exportInverseForeignKeys</td><td style="border-bottom: 0.5pt solid ; " align="left">export inverse foreign keys (default: true)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">customTypes</td><td style="border-bottom: 0.5pt solid ; " align="left">Custom user types (default: none)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">typeMappings</td><td style="border-bottom: 0.5pt solid ; " align="left">Mappings of table.column to Java type (default: none)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">numericMappings</td><td style="border-bottom: 0.5pt solid ; " align="left">Mappings of size/digits to Java type (default: none)</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left">imports</td><td style="" align="left">Array of java imports added to generated query classes: <span class="emphasis"><em>com.bar</em></span> for package (without .* notation), <span class="emphasis"><em>com.bar.Foo</em></span> for class (default: empty)
            </td></tr></tbody></table></div></div><br class="table-break"><p>Custom types can be used to register additional Type implementations:</p><pre class="programlisting">
<span class="hl-tag">&lt;customTypes&gt;</span>
  <span class="hl-tag">&lt;customType&gt;</span>com.querydsl.sql.types.InputStreamType<span class="hl-tag">&lt;/customType&gt;</span>
<span class="hl-tag">&lt;/customTypes&gt;</span>
</pre><p>Type mappings can be used to register table.column specific java types:</p><pre class="programlisting">
<span class="hl-tag">&lt;typeMappings&gt;</span>
  <span class="hl-tag">&lt;typeMapping&gt;</span>
    <span class="hl-tag">&lt;table&gt;</span>IMAGE<span class="hl-tag">&lt;/table&gt;</span>
    <span class="hl-tag">&lt;column&gt;</span>CONTENTS<span class="hl-tag">&lt;/column&gt;</span>
    <span class="hl-tag">&lt;type&gt;</span>java.io.InputStream<span class="hl-tag">&lt;/type&gt;</span>
  <span class="hl-tag">&lt;/typeMapping&gt;</span>
<span class="hl-tag">&lt;/typeMappings&gt;</span>
</pre><p>The defaults for the numeric mappings are </p><div class="table"><a name="d0e966"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Numeric mappings</b></p><div class="table-contents"><table summary="Numeric mappings" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col align="left"><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Total digits</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Decimal digits</th><th style="border-bottom: 0.5pt solid ; " align="left">Type</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">&gt; 18</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">0</td><td style="border-bottom: 0.5pt solid ; " align="left">BigInteger</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">&gt; 9</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">0</td><td style="border-bottom: 0.5pt solid ; " align="left">Long</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">&gt; 4</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">0</td><td style="border-bottom: 0.5pt solid ; " align="left">Integer</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">&gt; 2</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">0</td><td style="border-bottom: 0.5pt solid ; " align="left">Short</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">&gt; 0</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">0</td><td style="border-bottom: 0.5pt solid ; " align="left">Byte</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left">&gt; 0</td><td style="border-right: 0.5pt solid ; " align="left">&gt; 0</td><td style="" align="left">BigDecimal</td></tr></tbody></table></div></div><br class="table-break"><p>They can be customized for specific total/decimal digits combinations like this:</p><pre class="programlisting">
<span class="hl-tag">&lt;numericMappings&gt;</span>
  <span class="hl-tag">&lt;numericMapping&gt;</span>
    <span class="hl-tag">&lt;total&gt;</span>1<span class="hl-tag">&lt;/total&gt;</span>
    <span class="hl-tag">&lt;decimal&gt;</span>0<span class="hl-tag">&lt;/decimal&gt;</span>
    <span class="hl-tag">&lt;javaType&gt;</span>java.lang.Byte<span class="hl-tag">&lt;/javaType&gt;</span>
  <span class="hl-tag">&lt;/numericMapping&gt;</span>
<span class="hl-tag">&lt;/numericMappings&gt;</span>
</pre><p>Imports can be used to add cross-schema foreign keys support.</p><p>Schemas, tables and columns can also be renamed using the plugin. Here are some examples:</p><p>Renaming a schema:</p><pre class="programlisting">
<span class="hl-tag">&lt;renameMappings&gt;</span>
  <span class="hl-tag">&lt;renameMapping&gt;</span>
    <span class="hl-tag">&lt;fromSchema&gt;</span>PROD<span class="hl-tag">&lt;/fromSchema&gt;</span>
    <span class="hl-tag">&lt;toSchema&gt;</span>TEST<span class="hl-tag">&lt;/toSchema&gt;</span>
  <span class="hl-tag">&lt;/renameMapping&gt;</span>
<span class="hl-tag">&lt;/renameMappings&gt;</span>
</pre><p>Renaming a table:</p><pre class="programlisting">
<span class="hl-tag">&lt;renameMappings&gt;</span>
  <span class="hl-tag">&lt;renameMapping&gt;</span>
    <span class="hl-tag">&lt;fromSchema&gt;</span>PROD<span class="hl-tag">&lt;/fromSchema&gt;</span>
    <span class="hl-tag">&lt;fromTable&gt;</span>CUSTOMER<span class="hl-tag">&lt;/fromTable&gt;</span>
    <span class="hl-tag">&lt;toTable&gt;</span>CSTMR<span class="hl-tag">&lt;/toTable&gt;</span>
  <span class="hl-tag">&lt;/renameMapping&gt;</span>
<span class="hl-tag">&lt;/renameMappings&gt;</span>
</pre><p>Renaming a column:</p><pre class="programlisting">
<span class="hl-tag">&lt;renameMappings&gt;</span>
  <span class="hl-tag">&lt;renameMapping&gt;</span>
    <span class="hl-tag">&lt;fromSchema&gt;</span>PROD<span class="hl-tag">&lt;/fromSchema&gt;</span>
    <span class="hl-tag">&lt;fromTable&gt;</span>CUSTOMER<span class="hl-tag">&lt;/fromTable&gt;</span>
    <span class="hl-tag">&lt;fromColumn&gt;</span>ID<span class="hl-tag">&lt;/fromColumn&gt;</span>
    <span class="hl-tag">&lt;toColumn&gt;</span>IDX<span class="hl-tag">&lt;/toTable&gt;</span>
  <span class="hl-tag">&lt;/renameMapping&gt;</span>
<span class="hl-tag">&lt;/renameMappings&gt;</span>
</pre><p>Note: fromSchema can be omitted when renaming tables and columns.</p><p>Compared to APT based code generation certain functionality is not available such as QueryDelegate annotation handling.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1047"></a>2.3.3.&nbsp;Code generation via ANT</h3></div></div></div><p>
      The ANT task <code class="code">com.querydsl.sql.codegen.ant.AntMetaDataExporter</code>
      of the querydsl-sql module provides the same functionality as an ANT task.
      The configuration parameters of the task are the same as for the Maven plugin, except for the composite types.
    </p><p>
      The composite types are used without the wrapper element like in this example.
    </p><pre class="programlisting">
<span class="hl-tag">&lt;project</span> <span class="hl-attribute">name</span>=<span class="hl-value">"testproject"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"codegen"</span> <span class="hl-attribute">basedir</span>=<span class="hl-value">"."</span><span class="hl-tag">&gt;</span>

  <span class="hl-tag">&lt;taskdef</span> <span class="hl-attribute">name</span>=<span class="hl-value">"codegen"</span> <span class="hl-attribute">classname</span>=<span class="hl-value">"com.querydsl.sql.codegen.ant.AntMetaDataExporter"</span><span class="hl-tag">/&gt;</span>

  <span class="hl-tag">&lt;target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"codegen"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;codegen</span>
      <span class="hl-attribute">jdbcDriver</span>=<span class="hl-value">"org.h2.Driver"</span>
      <span class="hl-attribute">jdbcUser</span>=<span class="hl-value">"sa"</span>
      <span class="hl-attribute">jdbcUrl</span>=<span class="hl-value">"jdbc:h2:/dbs/db1"</span>
      <span class="hl-attribute">packageName</span>=<span class="hl-value">"test"</span>
      <span class="hl-attribute">targetFolder</span>=<span class="hl-value">"target/generated-sources/java"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;renameMapping</span> <span class="hl-attribute">fromSchema</span>=<span class="hl-value">"PUBLIC"</span> <span class="hl-attribute">toSchema</span>=<span class="hl-value">"PUB"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/codegen&gt;</span>
  <span class="hl-tag">&lt;/target&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1059"></a>2.3.4.&nbsp;Creating the query types</h3></div></div></div><p>To get started export your schema into Querydsl query types like this:</p><pre class="programlisting">
java.sql.Connection conn = ...;
MetaDataExporter exporter = <span class="hl-keyword">new</span> MetaDataExporter();
exporter.setPackageName(<span class="hl-string">"com.myproject.mydomain"</span>);
exporter.setTargetFolder(<span class="hl-keyword">new</span> File(<span class="hl-string">"target/generated-sources/java"</span>));
exporter.export(conn.getMetaData());
</pre><p>This declares that the database schema is to be mirrored into the
      com.myproject.domain package in the target/generated-sources/java folder.
    </p><p>
      The generated types have the table name transformed to mixed case as the class name and a
      similar mixed case transformation applied to the columns which are available as property
      paths in the query type.
    </p><p>
      In addition to this primary key and foreign key constraints are provided as fields
      which can be used for compact join declarations.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1072"></a>2.3.5.&nbsp;Configuration</h3></div></div></div><p>The configuration is done via the com.querydsl.sql.Configuration class which takes
      the
      Querydsl SQL dialect as an argument. For H2 you would create it like this</p><pre class="programlisting">
SQLTemplates templates = <span class="hl-keyword">new</span> H2Templates();
Configuration configuration = <span class="hl-keyword">new</span> Configuration(templates);
</pre><p>Querydsl uses SQL dialects to customize the SQL serialization needed for
      different relational databases. The available dialects are:
    </p><div class="itemizedlist"><ul type="disc"><li><p>CUBRIDTemplates (tested with CUBRID 8.4)</p></li><li><p>DB2Templates (tested with DB2 10.1.2)</p></li><li><p>DerbyTemplates (tested with Derby 10.8.2.2)</p></li><li><p>FirebirdTemplates (tested with Firebird 2.5)</p></li><li><p>HSQLDBTemplates (tested with HSQLDB 2.2.4)</p></li><li><p>H2Templates (tested with H2 1.3.164)</p></li><li><p>MySQLTemplates (tested with MySQL 5.5)</p></li><li><p>OracleTemplates (test with Oracle 10 and 11)</p></li><li><p>PostgreSQLTemplates (tested with PostgreSQL 9.1)</p></li><li><p>SQLiteTemplates (tested with xerial JDBC 3.7.2)</p></li><li><p>SQLServerTemplates (tested with SQL Server)</p></li><li><p>SQLServer2005Templates (for SQL Server 2005)</p></li><li><p>SQLServer2008Templates (for SQL Server 2008)</p></li><li><p>SQLServer2012Templates (for SQL Server 2012 and later)</p></li><li><p>TeradataTemplates (tested with Teradata 14)</p></li></ul></div><p>For customized SQLTemplates instances you can use the builder pattern like this</p><pre class="programlisting">
  H2Templates.builder()
     .printSchema() <span class="hl-comment">// to include the schema in the output</span>
     .quote()       <span class="hl-comment">// to quote names</span>
     .newLineToSingleSpace() <span class="hl-comment">// to replace new lines with single space in the output</span>
     .escape(ch)    <span class="hl-comment">// to set the escape char</span>
     .build();      <span class="hl-comment">// to get the customized SQLTemplates instance</span>
</pre><p>The methods of the Configuration class can be used to enable direct serialization of literals
    via setUseLiterals(true), override schema and tables and register custom types. For full details look
    at the javadocs of Configuration.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1133"></a>2.3.6.&nbsp;Querying</h3></div></div></div><p>For the following examples we will be using the <code class="code">SQLQueryFactory</code> class for query creation.
      Using it results in more concise code compared to constructor based query creation.</p><pre class="programlisting">
SQLQueryFactory queryFactory = <span class="hl-keyword">new</span> SQLQueryFactory(configuration, dataSource);
</pre><p>Querying with Querydsl SQL is as simple as this:</p><pre class="programlisting">
QCustomer customer = <span class="hl-keyword">new</span> QCustomer(<span class="hl-string">"c"</span>);

List&lt;String&gt; lastNames = queryFactory.select(customer.lastName).from(customer)
    .where(customer.firstName.eq(<span class="hl-string">"Bob"</span>))
    .fetch();
</pre><p>
      which is transformed into the following sql query, assuming that the related table
      name is <span class="emphasis"><em>customer</em></span>
      and the columns <span class="emphasis"><em>first_name</em></span>
      and <span class="emphasis"><em>last_name</em></span>:
    </p><pre class="programlisting">
SELECT c.last_name
FROM customer c
WHERE c.first_name = 'Bob'
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1160"></a>2.3.7.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the SQLQuery class like this</p><p>
      <span class="emphasis"><em>select:</em></span>
      Set the projection of the query. (Not necessary if created via query factory)
    </p><p>
      <span class="emphasis"><em>from:</em></span>
      Add the query sources here.
    </p><p>
      <span class="emphasis"><em>innerJoin, join, leftJoin, rightJoin, fullJoin, on:</em></span>
      Add join elements using these constructs.
      For the join methods the first argument is the join source and the second the target
      (alias).
    </p><p>
      <span class="emphasis"><em>where:</em></span>
      Add query filters, either in varargs form separated via commas or
      cascaded via the and-operator.
    </p><p>
      <span class="emphasis"><em>groupBy:</em></span>
      Add group by arguments in varargs form.
    </p><p>
      <span class="emphasis"><em>having:</em></span>
      Add having filter of the "group by" grouping as an varags array of
      Predicate expressions.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1205"></a>2.3.8.&nbsp;Joins</h3></div></div></div><p>Joins are constructed using the following syntax:</p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
QCompany company = QCompany.company;
queryFactory.select(customer.firstName, customer.lastName, company.name)
    .from(customer)
    .innerJoin(customer.company, company)
    .fetch();
</pre><p>and for a left join:</p><pre class="programlisting">
queryFactory.select(customer.firstName, customer.lastName, company.name)
    .from(customer)
    .leftJoin(customer.company, company)
    .fetch();
</pre><p>Alternatively the join condition can also be written out:</p><pre class="programlisting">
queryFactory.select(customer.firstName, customer.lastName, company.name)
    .from(customer)
    .leftJoin(company).on(customer.company.eq(company))
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1220"></a>2.3.9.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
queryFactory.select(customer.firstName, customer.lastName)
    .from(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.asc())
    .fetch();
</pre><p>which is equivalent to the following native SQL</p><pre class="programlisting">
SELECT c.first_name, c.last_name
FROM customer c
ORDER BY c.last_name ASC, c.first_name ASC
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1231"></a>2.3.10.&nbsp;Grouping</h3></div></div></div><p>Grouping can be done in the following form</p><pre class="programlisting">
queryFactory.select(customer.lastName)
    .from(customer)
    .groupBy(customer.lastName)
    .fetch();
</pre><p>which is equivalent to the following native SQL</p><pre class="programlisting">
SELECT c.last_name
FROM customer c
GROUP BY c.last_name
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1243"></a>2.3.11.&nbsp;Using Subqueries</h3></div></div></div><p>To create a subquery you can use one of the factory methods of <code class="code">SQLExpressions</code>
      and add the query parameters via from, where etc.
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
QCustomer customer2 = <span class="hl-keyword">new</span> QCustomer(<span class="hl-string">"customer2"</span>);
queryFactory.select(customer.all())
    .from(customer)
    .where(customer.status.eq(
        SQLExpressions.select(customer2.status.max()).from(customer2)))
    .fetch()
</pre><p>Another example</p><pre class="programlisting">
QStatus status = QStatus.status;
queryFactory.select(customer.all())
    .from(customer)
    .where(customer.status.in(
        SQLExpressions.select(status.id).from(status).where(status.level.lt(<span class="hl-value">3</span>))))
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1257"></a>2.3.12.&nbsp;Selecting literals</h3></div></div></div><p>To select literals you need to create constant instances for them like this:</p><pre class="programlisting">
queryFactory.select(Expressions.constant(<span class="hl-value">1</span>),
                    Expressions.constant(<span class="hl-string">"abc"</span>));
</pre><p>The class  <code class="code">com.querydsl.core.types.dsl.Expressions</code> offers also other useful static methods for
    projections, operation and template creation.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1269"></a>2.3.13.&nbsp;Query extension support</h3></div></div></div><p>Custom query extensions to support engine specific syntax can be created by
      subclassing AbstractSQLQuery and adding flagging methods like
      in the given MySQLQuery example:
    </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MySQLQuery&lt;T&gt; <span class="hl-keyword">extends</span> AbstractSQLQuery&lt;T, MySQLQuery&lt;T&gt;&gt; {

    <span class="hl-keyword">public</span> MySQLQuery(Connection conn) {
        <span class="hl-keyword">this</span>(conn, <span class="hl-keyword">new</span> MySQLTemplates(), <span class="hl-keyword">new</span> DefaultQueryMetadata());
    }

    <span class="hl-keyword">public</span> MySQLQuery(Connection conn, SQLTemplates templates) {
        <span class="hl-keyword">this</span>(conn, templates, <span class="hl-keyword">new</span> DefaultQueryMetadata());
    }

    <span class="hl-keyword">protected</span> MySQLQuery(Connection conn, SQLTemplates templates, QueryMetadata metadata) {
        <span class="hl-keyword">super</span>(conn, <span class="hl-keyword">new</span> Configuration(templates), metadata);
    }

    <span class="hl-keyword">public</span> MySQLQuery bigResult() {
        <span class="hl-keyword">return</span> addFlag(Position.AFTER_SELECT, <span class="hl-string">"SQL_BIG_RESULT "</span>);
    }

    <span class="hl-keyword">public</span> MySQLQuery bufferResult() {
        <span class="hl-keyword">return</span> addFlag(Position.AFTER_SELECT, <span class="hl-string">"SQL_BUFFER_RESULT "</span>);
    }


    <span class="hl-comment">// ...</span>
}
</pre><p>
      The flags are custom SQL snippets that can be inserted at specific points in the
      serialization. The supported positions are the enums of the
      <code class="code">com.querydsl.core.QueryFlag.Position</code> enum class.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1281"></a>2.3.14.&nbsp;Window functions</h3></div></div></div><p>Window functions are supported in Querydsl via the methods in the <code class="code">SQLExpressions</code> class.</p><p>Usage example:</p><pre class="programlisting">
queryFactory.select(SQLExpressions.rowNumber()
        .over()
        .partitionBy(employee.name)
        .orderBy(employee.id))
     .from(employee)
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1293"></a>2.3.15.&nbsp;Common table expressions</h3></div></div></div><p>Common table expressions are supported in Querydsl SQL via two syntax variants</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
queryFactory.with(employee, SQLExpressions.select(employee.all)
                                          .from(employee)
                                          .where(employee.name.startsWith(<span class="hl-string">"A"</span>)))
            .from(...)
</pre><p>And using a column listing</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
queryFactory.with(employee, employee.id, employee.name)
            .as(SQLExpressions.select(employee.id, employee.name)
                              .from(employee)
                              .where(employee.name.startsWith(<span class="hl-string">"A"</span>)))
            .from(...)
</pre><p>If the columns of the common table expression are a subset of an existing table or view
    it is advisable to use a generated path type for it, e.g. QEmployee in this case, but if the
    columns don't fit any existing table PathBuilder can be used instead.</p><p>Below is an example for such a case</p><pre class="programlisting">
QEmployee employee = QEmployee.employee;
QDepartment department = QDepartment.department;
PathBuilder&lt;Tuple&gt; emp = <span class="hl-keyword">new</span> PathBuilder&lt;Tuple&gt;(Tuple.<span class="hl-keyword">class</span>, <span class="hl-string">"emp"</span>);
queryFactory.with(emp, SQLExpressions.select(employee.id, employee.name, employee.departmentId,
                                          department.name.as(<span class="hl-string">"departmentName"</span>))
                                      .from(employee)
                                      .innerJoin(department).on(employee.departmentId.eq(department.id))))
            .from(...)
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1310"></a>2.3.16.&nbsp;Other SQL expressions</h3></div></div></div><p>
    Other SQL expressions are also available from the <code class="code">SQLExpressions</code> class as static methods.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1318"></a>2.3.17.&nbsp;Using Data manipulation commands</h3></div></div></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1321"></a>2.3.17.1.&nbsp;Insert</h4></div></div></div><p>With columns</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.insert(survey)
    .columns(survey.id, survey.name)
    .values(<span class="hl-value">3</span>, <span class="hl-string">"Hello"</span>).execute();
</pre><p>Without columns</p><pre class="programlisting">
queryFactory.insert(survey)
    .values(<span class="hl-value">4</span>, <span class="hl-string">"Hello"</span>).execute();
</pre><p>With subquery</p><pre class="programlisting">
queryFactory.insert(survey)
    .columns(survey.id, survey.name)
    .select(SQLExpressions.select(survey2.id.add(<span class="hl-value">1</span>), survey2.name).from(survey2))
    .execute();
</pre><p>With subquery, without columns</p><pre class="programlisting">
queryFactory.insert(survey)
    .select(SQLExpressions.select(survey2.id.add(<span class="hl-value">10</span>), survey2.name).from(survey2))
    .execute();
</pre><p>As an alternative to the columns/values usage, Querydsl provides also a set
     method which can be used like this</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.insert(survey)
    .set(survey.id, <span class="hl-value">3</span>)
    .set(survey.name, <span class="hl-string">"Hello"</span>).execute();
</pre><p>which is equivalent to the first example. Usage of the set method always
     expands internally to columns and values.</p><p>Beware that</p><pre class="programlisting">
columns(...).select(...)
</pre><p>maps the result set of the given query to be inserted whereas</p><p>To get the created keys out instead of modified rows count use one of the executeWithKey/s method.</p><pre class="programlisting">
set(...)
</pre><p>maps single columns and nulls are used for empty subquery results.</p><p>To populate a clause instance based on the contents of a bean you can use</p><pre class="programlisting">
queryFactory.insert(survey)
    .populate(surveyBean).execute();
</pre><p>This will exclude null bindings, if you need also null bindings use</p><pre class="programlisting">
queryFactory.insert(survey)
    .populate(surveyBean, DefaultMapper.WITH_NULL_BINDINGS).execute();
</pre></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1366"></a>2.3.17.2.&nbsp;Update</h4></div></div></div><p>With where</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.update(survey)
    .where(survey.name.eq(<span class="hl-string">"XXX"</span>))
    .set(survey.name, <span class="hl-string">"S"</span>)
    .execute();
</pre><p>Without where</p><pre class="programlisting">
queryFactory.update(survey)
    .set(survey.name, <span class="hl-string">"S"</span>)
    .execute();
</pre><p>Using bean population</p><pre class="programlisting">
queryFactory.update(survey)
    .populate(surveyBean)
    .execute();
</pre></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1381"></a>2.3.17.3.&nbsp;Delete</h4></div></div></div><p>With where</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.delete(survey)
    .where(survey.name.eq(<span class="hl-string">"XXX"</span>))
    .execute();

</pre><p>Without where</p><pre class="programlisting">
queryFactory.delete(survey)
    .execute()
</pre></div></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1392"></a>2.3.18.&nbsp;Batch support in DML clauses</h3></div></div></div><p>Querydsl SQL supports usage of JDBC batch updates through the DML APIs. If you
      have consecutive DML calls with a similar structure,
      you can bundle the the calls via addBatch() usage into one DMLClause. See the examples how
      it works for UPDATE, DELETE and INSERT.
    </p><p>Update:</p><pre class="programlisting">
QSurvey survey = QSurvey.survey;

queryFactory.insert(survey).values(<span class="hl-value">2</span>, <span class="hl-string">"A"</span>).execute();
queryFactory.insert(survey).values(<span class="hl-value">3</span>, <span class="hl-string">"B"</span>).execute();

SQLUpdateClause update = queryFactory.update(survey);
update.set(survey.name, <span class="hl-string">"AA"</span>).where(survey.name.eq(<span class="hl-string">"A"</span>)).addBatch();
update.set(survey.name, <span class="hl-string">"BB"</span>).where(survey.name.eq(<span class="hl-string">"B"</span>)).addBatch();
</pre><p>Delete:</p><pre class="programlisting">
queryFactory.insert(survey).values(<span class="hl-value">2</span>, <span class="hl-string">"A"</span>).execute();
queryFactory.insert(survey).values(<span class="hl-value">3</span>, <span class="hl-string">"B"</span>).execute();

SQLDeleteClause delete = queryFactory.delete(survey);
delete.where(survey.name.eq(<span class="hl-string">"A"</span>)).addBatch();
delete.where(survey.name.eq(<span class="hl-string">"B"</span>)).addBatch();
assertEquals(<span class="hl-value">2</span>, delete.execute());
</pre><p>Insert:</p><pre class="programlisting">
SQLInsertClause insert = queryFactory.insert(survey);
insert.set(survey.id, <span class="hl-value">5</span>).set(survey.name, <span class="hl-string">"5"</span>).addBatch();
insert.set(survey.id, <span class="hl-value">6</span>).set(survey.name, <span class="hl-string">"6"</span>).addBatch();
assertEquals(<span class="hl-value">2</span>, insert.execute());
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1409"></a>2.3.19.&nbsp;Bean class generation</h3></div></div></div><p>To create JavaBean DTO types for the tables of your schema use the
      MetaDataExporter like this:</p><pre class="programlisting">
java.sql.Connection conn = ...;
MetaDataExporter exporter = <span class="hl-keyword">new</span> MetaDataExporter();
exporter.setPackageName(<span class="hl-string">"com.myproject.mydomain"</span>);
exporter.setTargetFolder(<span class="hl-keyword">new</span> File(<span class="hl-string">"src/main/java"</span>));
exporter.setBeanSerializer(<span class="hl-keyword">new</span> BeanSerializer());
exporter.export(conn.getMetaData());
</pre><p>Now you can use the bean types as arguments to the populate method in DML
      clauses and you can project directly
      to bean types in queries. Here is a simple example in JUnit form:
    </p><pre class="programlisting">
QEmployee e = <span class="hl-keyword">new</span> QEmployee(<span class="hl-string">"e"</span>);

<span class="hl-comment">// Insert</span>
Employee employee = <span class="hl-keyword">new</span> Employee();
employee.setFirstname(<span class="hl-string">"John"</span>);
Integer id = queryFactory.insert(e).populate(employee).executeWithKey(e.id);
employee.setId(id);

<span class="hl-comment">// Update</span>
employee.setLastname(<span class="hl-string">"Smith"</span>);
assertEquals(<span class="hl-value">1l</span>, queryFactory.update(e).populate(employee).where(e.id.eq(employee.getId())).execute());

<span class="hl-comment">// Query</span>
Employee smith = queryFactory.selectFrom(e).where(e.lastname.eq(<span class="hl-string">"Smith"</span>)).fetchOne();
assertEquals(<span class="hl-string">"John"</span>, smith.getFirstname());

<span class="hl-comment">// Delete</span>
assertEquals(<span class="hl-value">1l</span>, queryFactory.delete(e).where(e.id.eq(employee.getId())).execute());
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1421"></a>2.3.20.&nbsp;Extracting the SQL query and bindings</h3></div></div></div><p>The SQL query and bindings can be extracted via the getSQL method:</p><pre class="programlisting">
SQLBindings bindings = query.getSQL();
System.out.println(bindings.getSQL());
</pre><p>If you need also all literals in the SQL string you can enable literal serialization on the
   query or configuration level via setUseLiterals(true).</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1430"></a>2.3.21.&nbsp;Custom types</h3></div></div></div><p>Querydsl SQL provides the possibility to declare custom type mappings for
      ResultSet/Statement interaction. The custom type mappings can be
      declared in com.querydsl.sql.Configuration instances, which are supplied as constructor
      arguments to the actual queries:
    </p><pre class="programlisting">
Configuration configuration = <span class="hl-keyword">new</span> Configuration(<span class="hl-keyword">new</span> H2Templates());
<span class="hl-comment">// overrides the mapping for Types.DATE</span>
configuration.register(<span class="hl-keyword">new</span> UtilDateType());
</pre><p>And for a table column</p><pre class="programlisting">
Configuration configuration = <span class="hl-keyword">new</span> Configuration(<span class="hl-keyword">new</span> H2Templates());
<span class="hl-comment">// declares a mapping for the gender column in the person table</span>
configuration.register(<span class="hl-string">"person"</span>, <span class="hl-string">"gender"</span>,  <span class="hl-keyword">new</span> EnumByNameType&lt;Gender&gt;(Gender.<span class="hl-keyword">class</span>));
</pre><p>To customize a numeric mapping you can use the registerNumeric method like this
    </p><pre class="programlisting">
configuration.registerNumeric(<span class="hl-value">5</span>,<span class="hl-value">2</span>,Float.<span class="hl-keyword">class</span>);
</pre><p>This will map the Float type to the NUMERIC(5,2) type.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1447"></a>2.3.22.&nbsp;Listening to queries and clauses</h3></div></div></div><p>SQLListener is a listener interface that can be used to listen to queries and DML clause. SQLListener
    instances can be registered either on the configuration and on the query/clause level via the addListener method.</p><p>Use cases for listeners are data synchronization, logging, caching and validation.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1454"></a>2.3.23.&nbsp;Spring integration</h3></div></div></div><p>Querydsl SQL integrates with Spring through the querydsl-sql-spring module:</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-sql-spring<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre><p>It provides Spring exception translation and a Spring connection provider for usage of Querydsl SQL
    with Spring transaction managers. Below is a configuration example:</p><pre class="programlisting">
<span class="hl-keyword">package</span> com.querydsl.example.config;

<span class="hl-keyword">import</span> com.querydsl.sql.H2Templates;
<span class="hl-keyword">import</span> com.querydsl.sql.SQLQueryFactory;
<span class="hl-keyword">import</span> com.querydsl.sql.SQLTemplates;
<span class="hl-keyword">import</span> com.querydsl.sql.spring.SpringConnectionProvider;
<span class="hl-keyword">import</span> com.querydsl.sql.spring.SpringExceptionTranslator;
<span class="hl-keyword">import</span> com.querydsl.sql.types.DateTimeType;
<span class="hl-keyword">import</span> com.querydsl.sql.types.LocalDateType;
<span class="hl-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hl-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hl-keyword">import</span> org.springframework.context.annotation.PropertySource;
<span class="hl-keyword">import</span> org.springframework.core.env.Environment;
<span class="hl-keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;
<span class="hl-keyword">import</span> org.springframework.transaction.PlatformTransactionManager;

<span class="hl-keyword">import</span> javax.inject.Inject;
<span class="hl-keyword">import</span> javax.inject.Provider;
<span class="hl-keyword">import</span> javax.sql.DataSource;
<span class="hl-keyword">import</span> java.sql.Connection;

<span class="hl-annotation">@Configuration</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcConfiguration {

    <span class="hl-annotation">@Bean</span>
    <span class="hl-keyword">public</span> DataSource dataSource() {
        <span class="hl-comment">// implementation omitted</span>
    }

    <span class="hl-annotation">@Bean</span>
    <span class="hl-keyword">public</span> PlatformTransactionManager transactionManager() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DataSourceTransactionManager(dataSource());
    }

    <span class="hl-annotation">@Bean</span>
    <span class="hl-keyword">public</span> com.querydsl.sql.Configuration querydslConfiguration() {
        SQLTemplates templates = H2Templates.builder().build(); <span class="hl-comment">//change to your Templates</span>
        com.querydsl.sql.Configuration configuration = <span class="hl-keyword">new</span> com.querydsl.sql.Configuration(templates);
        configuration.setExceptionTranslator(<span class="hl-keyword">new</span> SpringExceptionTranslator());
        <span class="hl-keyword">return</span> configuration;
    }

    <span class="hl-annotation">@Bean</span>
    <span class="hl-keyword">public</span> SQLQueryFactory queryFactory() {
        Provider&lt;Connection&gt; provider = <span class="hl-keyword">new</span> SpringConnectionProvider(dataSource());
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> SQLQueryFactory(querydslConfiguration(), provider);
    }

}
</pre></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spatial"></a>2.4.&nbsp;Querydsl Spatial</h2></div></div></div><p>Support for Spatial queries is available via the Querydsl Spatial module, which is an extension
  module to the SQL module. The Spatial module supports the object model of Simple Feature Access in queries
  and object binding.</p><p>The <a class="ulink" href="http://www.geolatte.org/" target="_top">geolatte</a> project is used for the object model.</p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="90%"><tr><td><img src="media/spatial.svg" width="100%"></td></tr></table><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1476"></a>2.4.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependency to your Maven project:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-sql-spatial<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre><p>Additionally the following database specific extra dependencies:</p><pre class="programlisting">
<span class="hl-comment">&lt;!-- for PostgreSQL usage --&gt;</span>
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>org.postgis<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>postgis-jdbc<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>1.3.3<span class="hl-tag">&lt;/version&gt;</span>
  <span class="hl-tag">&lt;scope&gt;</span>provided<span class="hl-tag">&lt;/scope&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-comment">&lt;!-- for Oracle usage --&gt;</span>
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>oracle<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>sdoapi<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>11.2.0<span class="hl-tag">&lt;/version&gt;</span>
  <span class="hl-tag">&lt;scope&gt;</span>provided<span class="hl-tag">&lt;/scope&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1487"></a>2.4.2.&nbsp;Code generation via Maven</h3></div></div></div><p>The code generation for Querydsl SQL can be set to detect the usage of spatial types in
    database schemas and use geolatte types in these case via the spatial property:</p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
    <span class="hl-tag">&lt;plugins&gt;</span>
      ...
      <span class="hl-tag">&lt;plugin&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
        ...
        <span class="hl-tag">&lt;configuration&gt;</span>
          ...
          <span class="hl-tag">&lt;spatial&gt;</span>true<span class="hl-tag">&lt;/spatial&gt;</span>
        <span class="hl-tag">&lt;/configuration&gt;</span>
      <span class="hl-tag">&lt;/plugin&gt;</span>
      ...
    <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1494"></a>2.4.3.&nbsp;Runtime configuration</h3></div></div></div><p>The runtime configuration aspect of the spatial module is that instead of the normal
    SQLTemplates instances, spatial enabled instances are used. Below is a list of spatial enabled
    SQLTemplates classes.</p><div class="itemizedlist"><ul type="disc"><li><p>GeoDBTemplates (for H2)</p></li><li><p>MySQLSpatialTemplates</p></li><li><p>OracleSpatialTemplates (alpha stage)</p></li><li><p>PostGISTemplates</p></li><li><p>SQLServer2008SpatialTemplates</p></li><li><p>TeradataSpatialTemplates</p></li></ul></div></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1518"></a>2.4.4.&nbsp;Querying</h3></div></div></div><p>With code generation and runtime configuration set for spatial types we can now try
    queries with it.</p><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1523"></a>2.4.4.1.&nbsp;Filter by Distance</h4></div></div></div><pre class="programlisting">
Geometry point = Wkt.fromWkt(<span class="hl-string">"Point(2 2)"</span>);
query.where(table.geo.distance(point).lt(<span class="hl-value">5.0</span>));
</pre><p>In addition to straight distance between geometries spherical and spheroidal distance are provided via
      distanceSphere and distanceSpheroid.</p></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1530"></a>2.4.4.2.&nbsp;Contains</h4></div></div></div><pre class="programlisting">
Geometry point = Wkt.fromWkt(<span class="hl-string">"Point(2 2)"</span>);
query.where(table.geo.contains(point));
</pre></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1535"></a>2.4.4.3.&nbsp;Intersection</h4></div></div></div><pre class="programlisting">
Geometry geo = query.select(table.geo1.intersection(table.geo2)).fetchOne();
</pre></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1540"></a>2.4.4.4.&nbsp;Access to the SPATIAL_REF_SYS table</h4></div></div></div><p>Unified access to the SPATIAL_REF_SYS standard table is provided via the QSpatialRefSys
      and SpatialRefSys classes. SPATIAL_REF_SYS contains data about the supported spatial reference systems.</p><pre class="programlisting">
QSpatialRefSys spatialRefSys = QSpatialRefSys.spatialRefSys;
List&lt;SpatialRefSys&gt; referenceSystems = query.select(spatialRefSys).from(spatialRefSys).fetch();
</pre></div></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1547"></a>2.4.5.&nbsp;Inheritance</h3></div></div></div><p>In case you use only generic geometry types in your database schema you can use conversion methods
    in the object model to convert to more specific types.</p><pre class="programlisting">
GeometryPath&lt;Geometry&gt; geometry = shapes.geometry;
PointPath&lt;Point&gt; point = geometry.asPoint();
NumberExpression&lt;Double&gt; pointX = point.x(); <span class="hl-comment">// x() is not available on GeometryExpression/GeometryPath</span>
</pre></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lucene_integration"></a>2.5.&nbsp;Querying Lucene</h2></div></div></div><p>This chapter describes the querying functionality of the Lucene module.</p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1559"></a>2.5.1.&nbsp;Maven integration</h3></div></div></div><p>
      Querydsl Lucene can be used via the querydsl-lucene3 module for Lucene 3, querydsl-lucene4
      for Lucene 4 and querydsl-lucene5 for Lucene 5
    </p><p>Lucene 3:</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-lucene3<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>slf4j-log4j12<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>1.6.1<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre><p>Lucene 4:</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-lucene4<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>slf4j-log4j12<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>1.6.1<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre><p>Lucene 5:</p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-lucene5<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>slf4j-log4j12<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>1.6.1<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1576"></a>2.5.2.&nbsp;Creating the query types</h3></div></div></div><p>With fields year and title a manually created query type could look something
      like this:</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> QDocument <span class="hl-keyword">extends</span> EntityPathBase&lt;Document&gt; {
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">long</span> serialVersionUID = -<span class="hl-value">4872833626508344081L</span>;

    <span class="hl-keyword">public</span> QDocument(String var) {
        <span class="hl-keyword">super</span>(Document.<span class="hl-keyword">class</span>, PathMetadataFactory.forVariable(var));
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">final</span> StringPath year = createString(<span class="hl-string">"year"</span>);

    <span class="hl-keyword">public</span> <span class="hl-keyword">final</span> StringPath title = createString(<span class="hl-string">"title"</span>);
}
</pre><p>QDocument represents a Lucene document with the fields year and title.</p><p>Code generation is not available for Lucene, since no schema data is available.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1587"></a>2.5.3.&nbsp;Querying</h3></div></div></div><p>Querying with Querydsl Lucene is as simple as this:</p><pre class="programlisting">
QDocument doc = <span class="hl-keyword">new</span> QDocument(<span class="hl-string">"doc"</span>);

IndexSearcher searcher = <span class="hl-keyword">new</span> IndexSearcher(index);
LuceneQuery query = <span class="hl-keyword">new</span> LuceneQuery(true, searcher);
List&lt;Document&gt; documents = query
    .where(doc.year.between(<span class="hl-string">"1800"</span>, <span class="hl-string">"2000"</span>).and(doc.title.startsWith(<span class="hl-string">"Huckle"</span>))
    .fetch();
</pre><p>which is transformed into the following Lucene query:</p><pre class="programlisting">
+year:[1800 TO 2000] +title:huckle*
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1598"></a>2.5.4.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the LuceneQuery class like this</p><p>
      <span class="emphasis"><em>where:</em></span>
      Add the query filters, either in varargs form separated via commas or
      cascaded via the and-operator. Supported operations are operations performed on PStrings except
      <span class="emphasis"><em>
        matches
      </em></span>
      ,
      <span class="emphasis"><em>indexOf</em></span>
      ,
      <span class="emphasis"><em>charAt</em></span>
      . Currently
      <span class="emphasis"><em>in</em></span>
      is
      not supported, but will be in the future.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1630"></a>2.5.5.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
query
    .where(doc.title.like(<span class="hl-string">"*"</span>))
    .orderBy(doc.title.asc(), doc.year.desc())
    .fetch();
</pre><p>which is equivalent to the following Lucene query</p><pre class="programlisting">
title:*
</pre><p>The results are sorted ascending based on title and year.</p><p>Alternatively a sort method call can be used to declare the sort logic as a Sort
      instance instead
    </p><pre class="programlisting">
Sort sort = ...;
query
    .where(doc.title.like(<span class="hl-string">"*"</span>))
    .sort(sort)
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1647"></a>2.5.6.&nbsp;Limit</h3></div></div></div><p>The syntax for declaring a limit is </p><pre class="programlisting">
query
    .where(doc.title.like(<span class="hl-string">"*"</span>))
    .limit(<span class="hl-value">10</span>)
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1654"></a>2.5.7.&nbsp;Offset</h3></div></div></div><p>The syntax for declaring an offset is </p><pre class="programlisting">
query
    .where(doc.title.like(<span class="hl-string">"*"</span>))
    .offset(<span class="hl-value">3</span>)
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1661"></a>2.5.8.&nbsp;Fuzzy searches</h3></div></div></div><p>Fuzzy searches can be expressed via fuzzyLike methods in the
      <code class="code">com.querydsl.lucene3.LuceneExpressions</code> class:
    </p><pre class="programlisting">
query
    .where(LuceneExpressions.fuzzyLike(doc.title, <span class="hl-string">"Hello"</span>))
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1671"></a>2.5.9.&nbsp;Applying Lucene filters to queries</h3></div></div></div><p>It is possible to apply a single Lucene filter to the query like this:</p><pre class="programlisting">
query
    .where(doc.title.like(<span class="hl-string">"*"</span>))
    .filter(filter)
    .fetch();
</pre><p>A shortcut for distinct filtering is provided via the distinct(Path) method:
    </p><pre class="programlisting">
query
    .where(doc.title.like(<span class="hl-string">"*"</span>))
    .distinct(doc.title)
    .fetch();
</pre></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hibernate_search_integration"></a>2.6.&nbsp;Querying Hibernate Search</h2></div></div></div><p>This chapter describes the querying functionality of
    the Hibernate Search module.
  </p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1687"></a>2.6.1.&nbsp;Creating the Querydsl query types</h3></div></div></div><p>
      See <a class="link" href="#jpa_integration" title="2.1.&nbsp;Querying JPA">Querying JPA/Hibernate sources</a>
      for instructions on how to create query types.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1695"></a>2.6.2.&nbsp;Querying</h3></div></div></div><p>Querying with Querydsl Hibernate Search is as simple as this:
    </p><pre class="programlisting">
QUser user = QUser.user;
SearchQuery&lt;User&gt; query = <span class="hl-keyword">new</span> SearchQuery&lt;User&gt;(session, user);
List&lt;User&gt; list = query
    .where(user.firstName.eq(<span class="hl-string">"Bob"</span>))
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1702"></a>2.6.3.&nbsp;General usage</h3></div></div></div><p>
      For general usage instructions see
      <a class="link" href="#lucene_integration" title="2.5.&nbsp;Querying Lucene">Querying Lucene sources</a>
      .
    </p><p>
      In the query serialization the only difference to the Querydsl Lucene module is that
      paths are treated differently.
      For <code class="code">org.hibernate.search.annotations.Field</code>
      annotated properties the
      name attribute is used with the property name as fallback for the field name.
    </p></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mongodb_integration"></a>2.7.&nbsp;Querying Mongodb</h2></div></div></div><p>This chapter describes the querying functionality of the Mongodb module.</p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1720"></a>2.7.1.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-apt<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
  <span class="hl-tag">&lt;scope&gt;</span>provided<span class="hl-tag">&lt;/scope&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-mongodb<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>slf4j-log4j12<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>1.6.1<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre><p>
      And now, configure the Maven APT plugin which generates the query types
      used by Querydsl:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
    <span class="hl-tag">&lt;plugins&gt;</span>
      ...
      <span class="hl-tag">&lt;plugin&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>com.mysema.maven<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>apt-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>1.1.3<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;executions&gt;</span>
          <span class="hl-tag">&lt;execution&gt;</span>
            <span class="hl-tag">&lt;goals&gt;</span>
              <span class="hl-tag">&lt;goal&gt;</span>process<span class="hl-tag">&lt;/goal&gt;</span>
            <span class="hl-tag">&lt;/goals&gt;</span>
            <span class="hl-tag">&lt;configuration&gt;</span>
              <span class="hl-tag">&lt;outputDirectory&gt;</span>target/generated-sources/java<span class="hl-tag">&lt;/outputDirectory&gt;</span>
              <span class="hl-tag">&lt;processor&gt;</span>com.querydsl.apt.morphia.MorphiaAnnotationProcessor<span class="hl-tag">&lt;/processor&gt;</span>
            <span class="hl-tag">&lt;/configuration&gt;</span>
          <span class="hl-tag">&lt;/execution&gt;</span>
        <span class="hl-tag">&lt;/executions&gt;</span>
      <span class="hl-tag">&lt;/plugin&gt;</span>
    ...
    <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>
      The MorphiaAnnotationProcessor finds domain types annotated with the
      <code class="code">com.google.code.morphia.annotations.Entity</code>
      annotation and generates Querydsl query types for them.
    </p><p>
      Run clean install and you will get your Query types generated into
      target/generated-sources/java.
    </p><p>
      If you use Eclipse, run mvn eclipse:eclipse to update your Eclipse project to
      include target/generated-sources/java as a source folder.
    </p><p>
      Now you are able to construct Mongodb queries and instances of the
      query domain model.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1742"></a>2.7.2.&nbsp;Querying</h3></div></div></div><p>Querying with Querydsl Mongodb with Morphia is as simple as this:
    </p><pre class="programlisting">
Morphia morphia;
Datastore datastore;
<span class="hl-comment">// ...</span>
QUser user = <span class="hl-keyword">new</span> QUser(<span class="hl-string">"user"</span>);
MorphiaQuery&lt;User&gt; query = <span class="hl-keyword">new</span> MorphiaQuery&lt;User&gt;(morphia, datastore, user);
List&lt;User&gt; list = query
    .where(user.firstName.eq(<span class="hl-string">"Bob"</span>))
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1749"></a>2.7.3.&nbsp;General usage</h3></div></div></div><p>Use the the cascading methods of the MongodbQuery class like this</p><p>
      <span class="emphasis"><em>where:</em></span>
      Add the query filters, either in varargs form separated via commas or
      cascaded via the and-operator. Supported operations are operations performed on PStrings except
      <span class="emphasis"><em>
        matches
      </em></span>
      ,
      <span class="emphasis"><em>indexOf</em></span>
      ,
      <span class="emphasis"><em>charAt</em></span>
      . Currently
      <span class="emphasis"><em>in</em></span>
      is
      not supported, but will be in the future.
    </p><p>
      <span class="emphasis"><em>orderBy:</em></span>
      Add ordering of the result as an varargs array of order expressions.
      Use asc() and desc() on numeric, string and other comparable expression to access the
      OrderSpecifier instances.
    </p><p>
      <span class="emphasis"><em>limit, offset, restrict:</em></span>
      Set the paging of the result. Limit for max results,
      offset for skipping rows and restrict for defining both in one call.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1781"></a>2.7.4.&nbsp;Ordering</h3></div></div></div><p>The syntax for declaring ordering is </p><pre class="programlisting">
query
    .where(doc.title.like(<span class="hl-string">"*"</span>))
    .orderBy(doc.title.asc(), doc.year.desc())
    .fetch();
</pre><p>The results are sorted ascending based on title and year.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1790"></a>2.7.5.&nbsp;Limit</h3></div></div></div><p>The syntax for declaring a limit is </p><pre class="programlisting">
query
    .where(doc.title.like(<span class="hl-string">"*"</span>))
    .limit(<span class="hl-value">10</span>)
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1797"></a>2.7.6.&nbsp;Offset</h3></div></div></div><p>The syntax for declaring an offset is </p><pre class="programlisting">
query
    .where(doc.title.like(<span class="hl-string">"*"</span>))
    .offset(<span class="hl-value">3</span>)
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1804"></a>2.7.7.&nbsp;Geospatial queries</h3></div></div></div><p>Support for geospatial queries is available for Double typed arrays (Double[])
      via the near-method:
    </p><pre class="programlisting">
query
    .where(geoEntity.location.near(<span class="hl-value">50.0</span>, <span class="hl-value">50.0</span>))
    .fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1811"></a>2.7.8.&nbsp;Select only relevant fields</h3></div></div></div><p>To select only relevant fields you can use the overloaded projection methods
      fetch, iterate, fetchOne and fetchFirst methods like this
    </p><pre class="programlisting">
query
    .where(doc.title.like(<span class="hl-string">"*"</span>))
    .fetch(doc.title, doc.path);
</pre><p>This query will load only the title and path fields of the documents.</p></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="collections_integration"></a>2.8.&nbsp;Querying Collections</h2></div></div></div><p>The querydsl-collections module can be used with generated query types and
    without.
    The first section describes the usage without generated query types:
  </p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1825"></a>2.8.1.&nbsp;Usage without generated query types</h3></div></div></div><p>
      To use querydsl-collections without generated query types you need to
      use the
      Querydsl alias feature. Here are some examples.
    </p><p>
      To get started, add the following static imports:
    </p><pre class="programlisting">
<span class="hl-comment">// needed for access of the Querydsl Collections API</span>
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> com.querydsl.collections.CollQueryFactory.*;
<span class="hl-comment">// needed, if you use the $-invocations</span>
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> com.querydsl.core.alias.Alias.*;
</pre><p>
      And now create an alias instance for the Cat class. Alias instances can only be
      created for non-final classes with an empty constructor. Make sure your class has one.
    </p><p>
      The alias instance of type Cat and its getter invocations are
      transformed into paths by wrapping them into dollar method invocations.
      The call
      <code class="code">c.getKittens()</code>
      for example is internally
      transformed into the property path <code class="code">c.kittens</code> inside the
      dollar method.
    </p><pre class="programlisting">
Cat c = alias(Cat.<span class="hl-keyword">class</span>, <span class="hl-string">"cat"</span>);
<span class="hl-keyword">for</span> (String name : select($(c.getName())).from($(c),cats)
  .where($(c.getKittens()).size().gt(<span class="hl-value">0</span>))
  .fetch()) {
    System.out.println(name);
}
</pre><p>
      The following example is a variation of the previous, where the access
      to the
      list size happens inside the dollar-method invocation.
    </p><pre class="programlisting">
Cat c = alias(Cat.<span class="hl-keyword">class</span>, <span class="hl-string">"cat"</span>);
<span class="hl-keyword">for</span> (String name : select($(c.getName())).from($(c),cats)
  .where($(c.getKittens().size()).gt(<span class="hl-value">0</span>))
  .fetch()) {
    System.out.println(name);
}
</pre><p>
      All non-primitive and non-final typed properties of aliases are aliases
      themselves. So you may cascade method calls until you hit a
      primitive or non-final type (e.g. java.lang.String) in the dollar-method scope.
    </p><p>
      e.g.
    </p><pre class="programlisting">
$(c.getMate().getName())
</pre><p>
      is transformed into
      <span class="emphasis"><em>c.mate.name</em></span>
      internally, but
    </p><pre class="programlisting">
$(c.getMate().getName().toLowerCase())
</pre><p>
      is not transformed properly, since the toLowerCase() invocation is not tracked.
    </p><p>
      Note also that you may only invoke getters, size(), contains(Object) and
      get(int) on alias types. All other invocations throw exceptions.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1867"></a>2.8.2.&nbsp;Usage with generated query types</h3></div></div></div><p>
      The example above can be expressed like this with generated expression types
    </p><pre class="programlisting">
QCat cat = <span class="hl-keyword">new</span> QCat(<span class="hl-string">"cat"</span>);
<span class="hl-keyword">for</span> (String name : select(cat.name).from(cat,cats)
  .where(cat.kittens.size().gt(<span class="hl-value">0</span>))
  .fetch()) {
    System.out.println(name);
}
</pre><p>When you use generated query types, you instantiate expressions instead of alias
      instances
      and use the property paths directly without any dollar-method wrapping.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1876"></a>2.8.3.&nbsp;Maven integration</h3></div></div></div><p>
      Add the following dependencies to your Maven project:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-apt<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
  <span class="hl-tag">&lt;scope&gt;</span>provided<span class="hl-tag">&lt;/scope&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-collections<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>

<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>slf4j-log4j12<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>1.6.1<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre><p>
      If you are not using JPA or JDO you can generate expression types for your
      domain types by
      annotating them with the
      <code class="code">com.querydsl.core.annotations.QueryEntity</code>
      annotation and adding the
      following plugin configuration into your Maven configuration (pom.xml):
    </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
  <span class="hl-tag">&lt;plugins&gt;</span>
    ...
    <span class="hl-tag">&lt;plugin&gt;</span>
      <span class="hl-tag">&lt;groupId&gt;</span>com.mysema.maven<span class="hl-tag">&lt;/groupId&gt;</span>
      <span class="hl-tag">&lt;artifactId&gt;</span>apt-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
      <span class="hl-tag">&lt;version&gt;</span>1.1.3<span class="hl-tag">&lt;/version&gt;</span>
      <span class="hl-tag">&lt;executions&gt;</span>
        <span class="hl-tag">&lt;execution&gt;</span>
          <span class="hl-tag">&lt;goals&gt;</span>
            <span class="hl-tag">&lt;goal&gt;</span>process<span class="hl-tag">&lt;/goal&gt;</span>
          <span class="hl-tag">&lt;/goals&gt;</span>
          <span class="hl-tag">&lt;configuration&gt;</span>
            <span class="hl-tag">&lt;outputDirectory&gt;</span>target/generated-sources/java<span class="hl-tag">&lt;/outputDirectory&gt;</span>
            <span class="hl-tag">&lt;processor&gt;</span>com.querydsl.apt.QuerydslAnnotationProcessor<span class="hl-tag">&lt;/processor&gt;</span>
          <span class="hl-tag">&lt;/configuration&gt;</span>
        <span class="hl-tag">&lt;/execution&gt;</span>
      <span class="hl-tag">&lt;/executions&gt;</span>
    <span class="hl-tag">&lt;/plugin&gt;</span>
    ...
  <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1890"></a>2.8.4.&nbsp;Ant integration</h3></div></div></div><p>Place the jar files from the full-deps bundle on your classpath and use the
      following tasks for Querydsl code generation:
    </p><pre class="programlisting">
    <span class="hl-comment">&lt;!-- APT based code generation --&gt;</span>
    <span class="hl-tag">&lt;javac</span> <span class="hl-attribute">srcdir</span>=<span class="hl-value">"${src}"</span> <span class="hl-attribute">classpathref</span>=<span class="hl-value">"cp"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"-proc:only"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"-processor"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"com.querydsl.apt.QuerydslAnnotationProcessor"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"-s"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;compilerarg</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${generated}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/javac&gt;</span>

    <span class="hl-comment">&lt;!-- compilation --&gt;</span>
    <span class="hl-tag">&lt;javac</span> <span class="hl-attribute">classpathref</span>=<span class="hl-value">"cp"</span> <span class="hl-attribute">destdir</span>=<span class="hl-value">"${build}"</span><span class="hl-tag">&gt;</span>
      <span class="hl-tag">&lt;src</span> <span class="hl-attribute">path</span>=<span class="hl-value">"${src}"</span><span class="hl-tag">/&gt;</span>
      <span class="hl-tag">&lt;src</span> <span class="hl-attribute">path</span>=<span class="hl-value">"${generated}"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/javac&gt;</span>
</pre><p>
      Replace
      <span class="emphasis"><em>src</em></span>
      with your main source folder,
      <span class="emphasis"><em>generated</em></span>
      with your folder for generated sources and
      <span class="emphasis"><em>build</em></span>
      with your target folder.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1908"></a>2.8.5.&nbsp;Hamcrest matchers</h3></div></div></div><p>Querydsl Collections provides Hamcrest matchers. With these imports</p><pre class="programlisting">
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.hamcrest.core.IsEqual.equalTo;
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> com.querydsl.collections.PathMatcher.hasValue;
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.junit.Assert.assertEquals;
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.junit.Assert.assertThat;
</pre><p>they can be used like this:</p><pre class="programlisting">
Car car = <span class="hl-keyword">new</span> Car();
car.setHorsePower(<span class="hl-value">123</span>);

assertThat(car, hasValue($.horsePower));
assertThat(car, hasValue($.horsePower, equalTo(<span class="hl-value">123</span>)));
</pre><p>
      The Hamcrest matchers have been contributed by
      <a class="ulink" href="https://github.com/jeroenvs" target="_top">Jeroen van Schagen</a>
      .
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1924"></a>2.8.6.&nbsp;Usage with the Eclipse Compiler for Java</h3></div></div></div><p>If Querydsl Collections is used with a JRE where the system compiler is not available,
    CollQuery instances can also be configured to use the Eclipse Compiler for Java (ECJ) instead:</p><pre class="programlisting">
DefaultEvaluatorFactory evaluatorFactory = <span class="hl-keyword">new</span> DefaultEvaluatorFactory(
    CollQueryTemplates.DEFAULT,
    <span class="hl-keyword">new</span> ECJEvaluatorFactory(getClass().getClassLoader()));
QueryEngine queryEngine = <span class="hl-keyword">new</span> DefaultQueryEngine(evaluatorFactory);
CollQuery query = <span class="hl-keyword">new</span> CollQuery(queryEngine);
</pre></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scala"></a>2.9.&nbsp;Querying in Scala</h2></div></div></div><p>Generic support for Querydsl usage in Scala is available via querydsl-scala
    module. To add it to your Maven build, use the following snippet:
  </p><pre class="programlisting">
<span class="hl-tag">&lt;dependency&gt;</span>
  <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
  <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-scala<span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
<span class="hl-tag">&lt;/dependency&gt;</span>
</pre><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1938"></a>2.9.1.&nbsp;DSL expressions for Scala</h3></div></div></div><p>Querydsl for Scala provides an alternative DSL for expression construction. The
      Scala DSL utilizes language features such as operator overloading,
      function pointers and implicit imports for enhanced readability and conciseness.
    </p><p>Here is an overview of the main alternatives :</p><pre class="programlisting">
//Standard              Alternative

expr isNotNull          expr is not(null)
expr isNull             expr is null
expr eq "Ben"           expr === "Ben"
expr ne "Ben"           expr !== "Ben"
expr append "X"         expr + "X"
expr isEmpty            expr is empty
expr isNotEmpty         expr not empty

// boolean
left and right          left &amp;&amp; right
left or right           left || right
expr not                !expr

// comparison
expr lt 5               expr &lt; 5
expr loe 5              expr &lt;= 5
expr gt 5               expr &gt; 5
expr goe 5              expr &gt;= 5
expr notBetween(2,6)    expr not between (2,6)
expr negate             -expr

// numeric
expr add 3              expr + 3
expr subtract 3         expr - 3
expr divide 3           expr / 3
expr multiply 3         expr * 3
expr mod 5              expr % 5

// collection
list.get(0)             list(0)
map.get("X")            map("X")
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1948"></a>2.9.2.&nbsp;Querying with SQL</h3></div></div></div><p>
      Like with Querydsl SQL for Java you need to generate Query types to be able to construct
      your queries. The following code examples show how this is done:
    </p><p>Generation without Bean types :</p><pre class="programlisting">
val directory = <span class="hl-keyword">new</span> java.io.File(<span class="hl-string">"target/jdbcgen1"</span>)
val namingStrategy = <span class="hl-keyword">new</span> DefaultNamingStrategy()
val exporter = <span class="hl-keyword">new</span> MetaDataExporter()
exporter.setNamePrefix(<span class="hl-string">"Q"</span>)
exporter.setPackageName(<span class="hl-string">"com.querydsl"</span>)
exporter.setSchemaPattern(<span class="hl-string">"PUBLIC"</span>)
exporter.setTargetFolder(directory)
exporter.setSerializerClass(classOf[ScalaMetaDataSerializer])
exporter.setCreateScalaSources(true)
exporter.setTypeMappings(ScalaTypeMappings.create)
exporter.export(connection.getMetaData)
</pre><p>Generation with Bean types :</p><pre class="programlisting">
val directory = <span class="hl-keyword">new</span> java.io.File(<span class="hl-string">"target/jdbcgen2"</span>)
val namingStrategy = <span class="hl-keyword">new</span> DefaultNamingStrategy()
val exporter = <span class="hl-keyword">new</span> MetaDataExporter()
exporter.setNamePrefix(<span class="hl-string">"Q"</span>)
exporter.setPackageName(<span class="hl-string">"com.querydsl"</span>)
exporter.setSchemaPattern(<span class="hl-string">"PUBLIC"</span>)
exporter.setTargetFolder(directory)
exporter.setSerializerClass(classOf[ScalaMetaDataSerializer])
exporter.setBeanSerializerClass(classOf[ScalaBeanSerializer])
exporter.setCreateScalaSources(true)
exporter.setTypeMappings(ScalaTypeMappings.create)
exporter.export(connection.getMetaData)
</pre><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1961"></a>2.9.2.1.&nbsp;Code generation</h4></div></div></div><p>Scala sources for SQL metatypes and projections can be generated with
        querydsl-maven-plugin. Here is an example configuration
      </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
    <span class="hl-tag">&lt;plugins&gt;</span>
      ...
      <span class="hl-tag">&lt;plugin&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;configuration&gt;</span>
          <span class="hl-tag">&lt;jdbcDriver&gt;</span>com.mysql.jdbc.Driver<span class="hl-tag">&lt;/jdbcDriver&gt;</span>
          <span class="hl-tag">&lt;jdbcUrl&gt;</span>jdbc:mysql://localhost:3306/test<span class="hl-tag">&lt;/jdbcUrl&gt;</span>
          <span class="hl-tag">&lt;jdbcUser&gt;</span>matko<span class="hl-tag">&lt;/jdbcUser&gt;</span>
          <span class="hl-tag">&lt;jdbcPassword&gt;</span>matko<span class="hl-tag">&lt;/jdbcPassword&gt;</span>
          <span class="hl-tag">&lt;packageName&gt;</span>com.example.schema<span class="hl-tag">&lt;/packageName&gt;</span>
          <span class="hl-tag">&lt;targetFolder&gt;</span>${project.basedir}/src/main/scala<span class="hl-tag">&lt;/targetFolder&gt;</span>
          <span class="hl-tag">&lt;exportBeans&gt;</span>true<span class="hl-tag">&lt;/exportBeans&gt;</span>
          <span class="hl-tag">&lt;createScalaSources&gt;</span>true<span class="hl-tag">&lt;/createScalaSources&gt;</span>
        <span class="hl-tag">&lt;/configuration&gt;</span>
        <span class="hl-tag">&lt;dependencies&gt;</span>
          <span class="hl-tag">&lt;dependency&gt;</span>
            <span class="hl-tag">&lt;groupId&gt;</span>mysql<span class="hl-tag">&lt;/groupId&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>mysql-connector-java<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;version&gt;</span>5.1.16<span class="hl-tag">&lt;/version&gt;</span>
          <span class="hl-tag">&lt;/dependency&gt;</span>
          <span class="hl-tag">&lt;dependency&gt;</span>
            <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-scala<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
          <span class="hl-tag">&lt;/dependency&gt;</span>
          <span class="hl-tag">&lt;dependency&gt;</span>
            <span class="hl-tag">&lt;groupId&gt;</span>org.scala-lang<span class="hl-tag">&lt;/groupId&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>scala-library<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;version&gt;</span>${scala.version}<span class="hl-tag">&lt;/version&gt;</span>
          <span class="hl-tag">&lt;/dependency&gt;</span>
        <span class="hl-tag">&lt;/dependencies&gt;</span>
      <span class="hl-tag">&lt;/plugin&gt;</span>
      ...
    <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>The maven goal to execute is querydsl:export.</p></div></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1970"></a>2.9.3.&nbsp;Querying with other backends</h3></div></div></div><p>When querying with other backends the Expression model has to be created
      manually or alternatively the alias functionality can be used.
    </p><p>Here is a minimal example with JPA :</p><pre class="programlisting">
<span class="hl-annotation">@Entity</span>
<span class="hl-keyword">class</span> User {
  <span class="hl-annotation">@BeanProperty</span>
  <span class="hl-annotation">@Id</span>
  var id: Integer = _;
  <span class="hl-annotation">@BeanProperty</span>
  var userName: String = _;
  <span class="hl-annotation">@BeanProperty</span>
  <span class="hl-annotation">@ManyToOne</span>
  var department: Department = _;
}

<span class="hl-annotation">@Entity</span>
<span class="hl-keyword">class</span> Department {
  <span class="hl-annotation">@BeanProperty</span>
  <span class="hl-annotation">@Id</span>
  var id: Integer = _;
  <span class="hl-annotation">@BeanProperty</span>
  var name: String = _;
}
</pre><p>And here are some query examples</p><p>List</p><pre class="programlisting">
val person = Person as <span class="hl-string">"person"</span>

selectFrom(person).where(person.firstName like <span class="hl-string">"Rob%"</span>).fetch()
</pre><p>Unique result</p><pre class="programlisting">
selectFrom(person).where(person.firstName like <span class="hl-string">"Rob%"</span>).fetchOne()
</pre><p>Long where</p><pre class="programlisting">
selectFrom(person)
  .where(person.firstName like <span class="hl-string">"Rob%"</span>, person.lastName like <span class="hl-string">"An%"</span>)
  .fetch()
</pre><p>Order</p><pre class="programlisting">
selectFrom(person).orderBy(person.firstName asc).fetch()
</pre><p>Not null</p><pre class="programlisting">
selectFrom(person)
  .where(person.firstName isEmpty, person.lastName isNotNull)
  .fetch()
</pre><p>The factory method for query creation is</p><pre class="programlisting">
def query() = <span class="hl-keyword">new</span> JPAQuery(entityManager)
</pre><p>In addition to queries you need variables which can be created like this</p><pre class="programlisting">
val person = Person as <span class="hl-string">"person"</span>
</pre><p>Note: the Scala support is not yet available if you use Hibernate with an XML based configuration. HibernateDomainExporter currently only outputs Java source files.</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a name="general"></a>3.&nbsp;General usage</h2></div></div></div><p>
    The General usage section covers aspects that are not covered in the tutorial section of the reference documentation.
    It follows a use case oriented structure.
    </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="creating_queries"></a>3.1.&nbsp;Creating queries</h2></div></div></div><p>Query construction in Querydsl involves calling query methods with expression arguments. Since
  query methods are mostly module specific and have already been presented in the tutorial section,
  this part will focus on expressions.</p><p>Expressions are normally constructed by accessing fields and calling methods on the generated
  expression types of your domain module. For cases where code generation is not applicable generic ways
  to construct expressions can be used instead.</p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2023"></a>3.1.1.&nbsp;Complex predicates</h3></div></div></div><p>
      To construct complex boolean expressions, use the <code class="code">com.querydsl.core.BooleanBuilder</code> class. It
      implements Predicate and can be used in cascaded form:
    </p><pre class="programlisting">
<span class="hl-keyword">public</span> List&lt;Customer&gt; getCustomer(String... names) {
    QCustomer customer = QCustomer.customer;
    JPAQuery&lt;Customer&gt; query = queryFactory.selectFrom(customer);
    BooleanBuilder builder = <span class="hl-keyword">new</span> BooleanBuilder();
    <span class="hl-keyword">for</span> (String name : names) {
        builder.or(customer.name.eq(name));
    }
    query.where(builder); <span class="hl-comment">// customer.name eq name1 OR customer.name eq name2 OR ...</span>
    <span class="hl-keyword">return</span> query.fetch();
}
</pre><p><code class="code">BooleanBuilder</code> is mutable and represents initially null and after each <code class="code">and</code>
    or <code class="code">or</code> call the result of the operation.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2043"></a>3.1.2.&nbsp;Dynamic expressions</h3></div></div></div><p>
      The <code class="code">com.querydsl.core.types.dsl.Expressions</code>
      class is a static factory class for dynamic expression construction.
      The factory methods are named by the returned type and are mostly self-documenting.
    </p><p>
    In general the <code class="code">Expressions</code> class should be used only in cases where fluent DSL forms
    can't be used, such as dynamic paths, custom syntax or custom operations.
    </p><p>The following expression </p><pre class="programlisting">
QPerson person = QPerson.person;
person.firstName.startsWith(<span class="hl-string">"P"</span>);
</pre><p>could be constructed like this if Q-types wouldn't be available </p><pre class="programlisting">
Path&lt;Person&gt; person = Expressions.path(Person.<span class="hl-keyword">class</span>, <span class="hl-string">"person"</span>);
Path&lt;String&gt; personFirstName = Expressions.path(String.<span class="hl-keyword">class</span>, person, <span class="hl-string">"firstName"</span>);
Constant&lt;String&gt; constant = Expressions.constant(<span class="hl-string">"P"</span>);
Expressions.predicate(Ops.STARTS_WITH, personFirstName, constant);
</pre><p>Path instances represent variables and properties, Constants are constants,
      Operations are operations and TemplateExpression instances can be used to express
      expressions as String templates.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2066"></a>3.1.3.&nbsp;Dynamic paths</h3></div></div></div><p>In addition to the <code class="code">Expressions</code> based expression creation Querydsl provides
    also a more fluent API for dynamic path creation.</p><p>
      For dynamic path generation the <code class="code">com.querydsl.core.types.dsl.PathBuilder</code> class can be used. It extends
      <code class="code">EntityPathBase</code> and can be used as an alternative to class generation and alias-usage
      for path generation.
    </p><p>
    Compared to the Expressions API PathBuilder doesn't provide direct support for unknown operations
    or custom syntax, but the syntax is closer to the normal DSL.
    </p><p>String property:</p><pre class="programlisting">
PathBuilder&lt;User&gt; entityPath = <span class="hl-keyword">new</span>
PathBuilder&lt;User&gt;(User.<span class="hl-keyword">class</span>, <span class="hl-string">"entity"</span>);
<span class="hl-comment">// fully generic access</span>
entityPath.get(<span class="hl-string">"userName"</span>);
<span class="hl-comment">// .. or with supplied type</span>
entityPath.get(<span class="hl-string">"userName"</span>, String.<span class="hl-keyword">class</span>);
<span class="hl-comment">// .. and correct signature</span>
entityPath.getString(<span class="hl-string">"userName"</span>).lower();
</pre><p>List property with component type: </p><pre class="programlisting">
entityPath.getList(<span class="hl-string">"list"</span>, String.<span class="hl-keyword">class</span>).get(<span class="hl-value">0</span>);
</pre><p>Using a component expression type:</p><pre class="programlisting">
entityPath.getList(<span class="hl-string">"list"</span>, String.<span class="hl-keyword">class</span>, StringPath.<span class="hl-keyword">class</span>).get(<span class="hl-value">0</span>).lower();
</pre><p>Map property with key and value type: </p><pre class="programlisting">
entityPath.getMap(<span class="hl-string">"map"</span>, String.<span class="hl-keyword">class</span>, String.<span class="hl-keyword">class</span>).get(<span class="hl-string">"key"</span>);
</pre><p>Using a component expression type:</p><pre class="programlisting">
entityPath.getMap(<span class="hl-string">"map"</span>, String.<span class="hl-keyword">class</span>, String.<span class="hl-keyword">class</span>, StringPath.<span class="hl-keyword">class</span>).get(<span class="hl-string">"key"</span>).lower();
</pre><p>For PathBuilder validation a PathBuilderValidator can be used. It can be injected in the constructor
    and will be used transitively for the new PathBuilder</p><pre class="programlisting">
PathBuilder&lt;Customer&gt; customer = <span class="hl-keyword">new</span> PathBuilder&lt;Customer&gt;(Customer.<span class="hl-keyword">class</span>, <span class="hl-string">"customer"</span>, validator);
</pre><p>PathBuilderValidator.FIELDS will verify field existence, PathBuilderValidator.PROPERTIES validates
      Bean properties and JPAPathBuilderValidator validates using a JPA metamodel.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2110"></a>3.1.4.&nbsp;Case expressions</h3></div></div></div><p>To construct case-when-then-else expressions use the
      <code class="code">CaseBuilder</code> class like this:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
Expression&lt;String&gt; cases = <span class="hl-keyword">new</span> CaseBuilder()
    .when(customer.annualSpending.gt(<span class="hl-value">10000</span>)).then(<span class="hl-string">"Premier"</span>)
    .when(customer.annualSpending.gt(<span class="hl-value">5000</span>)).then(<span class="hl-string">"Gold"</span>)
    .when(customer.annualSpending.gt(<span class="hl-value">2000</span>)).then(<span class="hl-string">"Silver"</span>)
    .otherwise(<span class="hl-string">"Bronze"</span>);
<span class="hl-comment">// The cases expression can now be used in a projection or condition</span>
</pre><p>For case expressions with equals-operations use the following simpler form instead:
    </p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
Expression&lt;String&gt; cases = customer.annualSpending
    .when(<span class="hl-value">10000</span>).then(<span class="hl-string">"Premier"</span>)
    .when(<span class="hl-value">5000</span>).then(<span class="hl-string">"Gold"</span>)
    .when(<span class="hl-value">2000</span>).then(<span class="hl-string">"Silver"</span>)
    .otherwise(<span class="hl-string">"Bronze"</span>);
<span class="hl-comment">// The cases expression can now be used in a projection or condition</span>
</pre><p>Case expressions are not yet supported in JDOQL.</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2126"></a>3.1.5.&nbsp;Casting expressions</h3></div></div></div><p>
      To avoid a generic signature in expression types the type hierarchies are
      flattened. The result is that all generated query types are direct subclasses of
      <code class="code">com.querydsl.core.types.dsl.EntityPathBase</code>
      or
      <code class="code">com.querydsl.core.types.dsl.BeanPath</code>
      and cannot be directly cast to their logical supertypes.
    </p><p>
      Instead of a direct Java cast, the supertype reference is accessible via the
      <code class="code">_super</code> field. A _super-field is available in all generated query types with a single
      supertype:
    </p><pre class="programlisting">
<span class="hl-comment">// from Account</span>
QAccount <span class="hl-keyword">extends</span> EntityPathBase&lt;Account&gt; {
    <span class="hl-comment">// ...</span>
}

<span class="hl-comment">// from BankAccount extends Account</span>
QBankAccount <span class="hl-keyword">extends</span> EntityPathBase&lt;BankAccount&gt; {

    <span class="hl-keyword">public</span> <span class="hl-keyword">final</span> QAccount _super = <span class="hl-keyword">new</span> QAccount(<span class="hl-keyword">this</span>);

    <span class="hl-comment">// ...</span>
}
</pre><p>To cast from a supertype to a subtype you can use the
      as-method of the
      EntityPathBase class:
    </p><pre class="programlisting">
QAccount account = <span class="hl-keyword">new</span> QAccount(<span class="hl-string">"account"</span>);
QBankAccount bankAccount = account.as(QBankAccount.<span class="hl-keyword">class</span>);
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2148"></a>3.1.6.&nbsp;Select literals</h3></div></div></div><p>Literals can be selected by referring to them via Constant expressions. Here is a simple example </p><pre class="programlisting">
query.select(Expressions.constant(<span class="hl-value">1</span>),
             Expressions.constant(<span class="hl-string">"abc"</span>));
</pre><p>Constant expressions are often used in subqueries.</p></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="result_handling"></a>3.2.&nbsp;Result handling</h2></div></div></div><p>Querydsl provides two ways to customize results, FactoryExpressions for row based transformation
  and ResultTransformer for aggregation.</p><p>The <code class="code">com.querydsl.core.types.FactoryExpression</code> interface is used for Bean creation,
  constructor invocation and for the creation of more complex objects. The functionality of the
  FactoryExpression implementations of Querydsl can be accessed via the
  <code class="code">com.querydsl.core.types.Projections</code> class.</p><p>For the <code class="code">com.querydsl.core.ResultTransformer</code> interface <code class="code">GroupBy</code> is the
  main implementation.</p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2178"></a>3.2.1.&nbsp;Returning multiple columns</h3></div></div></div><p>Since Querydsl 3.0 the default type for multi-column results is <code class="code">com.querydsl.core.Tuple</code>.
    Tuple provides provides a typesafe Map like interface to access column data from a Tuple row object.</p><pre class="programlisting">
List&lt;Tuple&gt; result = query.select(employee.firstName, employee.lastName)
                          .from(employee).fetch();
<span class="hl-keyword">for</span> (Tuple row : result) {
     System.out.println(<span class="hl-string">"firstName "</span> + row.get(employee.firstName));
     System.out.println(<span class="hl-string">"lastName "</span> + row.get(employee.lastName));
}}
</pre><p>This example could also have been written via the QTuple expression class like this</p><pre class="programlisting">
List&lt;Tuple&gt; result = query.select(<span class="hl-keyword">new</span> QTuple(employee.firstName, employee.lastName))
                          .from(employee).fetch();
<span class="hl-keyword">for</span> (Tuple row : result) {
     System.out.println(<span class="hl-string">"firstName "</span> + row.get(employee.firstName));
     System.out.println(<span class="hl-string">"lastName "</span> + row.get(employee.lastName));
}}
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2192"></a>3.2.2.&nbsp;Bean population</h3></div></div></div><p>In cases where Beans need to be populated based on the results of the query, Bean projections
    can be used like this</p><pre class="programlisting">
List&lt;UserDTO&gt; dtos = query.select(
    Projections.bean(UserDTO.<span class="hl-keyword">class</span>, user.firstName, user.lastName)).fetch();
</pre><p>When fields should be directly used instead of setters the following variant can be
   used instead</p><pre class="programlisting">
List&lt;UserDTO&gt; dtos = query.select(
    Projections.fields(UserDTO.<span class="hl-keyword">class</span>, user.firstName, user.lastName)).fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2203"></a>3.2.3.&nbsp;Constructor usage</h3></div></div></div><p>Constructor based row transformation can be used like this</p><pre class="programlisting">
List&lt;UserDTO&gt; dtos = query.select(
    Projections.constructor(UserDTO.<span class="hl-keyword">class</span>, user.firstName, user.lastName)).fetch();
</pre><p>As an alternative to the generic Constructor expression usage constructors
    can also be annotated with the <code class="code">QueryProjection</code> annotation:
    </p><pre class="programlisting">
<span class="hl-keyword">class</span> CustomerDTO {

  <span class="hl-annotation">@QueryProjection</span>
  <span class="hl-keyword">public</span> CustomerDTO(<span class="hl-keyword">long</span> id, String name) {
     ...
  }

}
</pre><p>And then you can use it like this in the query</p><pre class="programlisting">
QCustomer customer = QCustomer.customer;
JPQLQuery query = <span class="hl-keyword">new</span> HibernateQuery(session);
List&lt;CustomerDTO&gt; dtos = query.select(<span class="hl-keyword">new</span> QCustomerDTO(customer.id, customer.name))
                              .from(customer).fetch();
</pre><p>While the example is Hibernate specific, this feature is
      available in all modules.
    </p><p>If the type with the QueryProjection annotation is not an annotated entity
      type, you can use the constructor projection like in the example, but if the
      annotated type would be an entity type, then the constructor projection would need to be
      created via a call to the static create method of the query type:
    </p><pre class="programlisting">
<span class="hl-annotation">@Entity</span>
<span class="hl-keyword">class</span> Customer {

  <span class="hl-annotation">@QueryProjection</span>
  <span class="hl-keyword">public</span> Customer(<span class="hl-keyword">long</span> id, String name) {
     ...
  }

}
</pre><pre class="programlisting">
QCustomer customer = QCustomer.customer;
JPQLQuery query = <span class="hl-keyword">new</span> HibernateQuery(session);
List&lt;Customer&gt; dtos = query.select(QCustomer.create(customer.id, customer.name))
                           .from(customer).fetch();
</pre><p>Alternatively, if code generation is not an option, you can
      create a constructor projection like this:
    </p><pre class="programlisting">
List&lt;Customer&gt; dtos = query
    .select(Projections.constructor(Customer.<span class="hl-keyword">class</span>, customer.id, customer.name))
    .from(customer).fetch();
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2233"></a>3.2.4.&nbsp;Result aggregation</h3></div></div></div><p>
      The
      <code class="code">com.querydsl.core.group.GroupBy</code>
      class provides aggregation functionality which can be used to aggregate query results
      in memory. Below are some usage examples.
    </p><p>
      Aggregating parent child relations
    </p><pre class="programlisting">
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> com.querydsl.core.group.GroupBy.*;

Map&lt;Integer, List&lt;Comment&gt;&gt; results = query.from(post, comment)
    .where(comment.post.id.eq(post.id))
    .transform(groupBy(post.id).as(list(comment)));
</pre><p>This will return a map of post ids to related comments.</p><p>Multiple result columns</p><pre class="programlisting">
Map&lt;Integer, Group&gt; results = query.from(post, comment)
    .where(comment.post.id.eq(post.id))
    .transform(groupBy(post.id).as(post.name, set(comment.id)));
</pre><p>This will return a map of post ids to Group instances with
      access to post name
      and comment ids.
    </p><p>Group is the GroupBy equivalent to the Tuple interface.</p><p>
      More examples can be found
      <a class="ulink" href="https://github.com/querydsl/querydsl/blob/master/querydsl-collections/src/test/java/com/querydsl/collections/GroupByTest.java" target="_top">here</a>
      .
    </p></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="codegen"></a>3.3.&nbsp;Code generation</h2></div></div></div><p>The Java 6 APT annotation processing functionality is used in Querydsl for code
    generation in the JPA, JDO and Mongodb modules. This section describes various configuration
    options for the code generation and an alternative to APT usage.
  </p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2265"></a>3.3.1.&nbsp;Path initialization</h3></div></div></div><p>
      By default Querydsl initializes only reference properties of the first two levels. In cases where
      longer initialization paths are required, these have to be annotated in the domain
      types via
       <code class="code">com.querydsl.core.annotations.QueryInit</code>
      annotations. QueryInit is used on properties where deep initializations are
      needed. The following example demonstrates the usage.
    </p><pre class="programlisting">
<span class="hl-annotation">@Entity</span>
<span class="hl-keyword">class</span> Event {
    <span class="hl-annotation">@QueryInit("customer.address")</span>
    Account account;
}

<span class="hl-annotation">@Entity</span>
<span class="hl-keyword">class</span> Account {
    Customer customer;
}

<span class="hl-annotation">@Entity</span>
<span class="hl-keyword">class</span> Customer {
    String name;
    Address address;
    <span class="hl-comment">// ...</span>
}
</pre><p>
      This example enforces the initialization of the account.customer path, when an
      Event path is initialized as a root path / variable. The path initialization
      format supports wildcards as well, e.g. "customer.*" or just "*".
    </p><p>
      The automatic path initialization replaces the manual one, which
      required the entity fields to be non-final. The declarative format has the benefit
      to be applied to all top level instances of a Query type and to enable the usage
      of final entity fields.
    </p><p>
      Automatic path initialization is the preferred initialization strategy, but
      manual initialization can be activated via the Config annotation, which is
      described below.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2281"></a>3.3.2.&nbsp;Customization</h3></div></div></div><p>
      The serialization of Querydsl can be customized via Config annotations on
      packages and types. They customize the serialization of the annotated package or type.
    </p><p>
      The serialization options are
    </p><div class="table"><a name="d0e2288"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Config options</b></p><div class="table-contents"><table summary="Config options" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Name</th><th style="border-bottom: 0.5pt solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">entityAccessors</td><td style="border-bottom: 0.5pt solid ; " align="left">accessor methods for entity paths instead of public final fields (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">listAccessors</td><td style="border-bottom: 0.5pt solid ; " align="left">listProperty(int index) style methods (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">mapAccessors</td><td style="border-bottom: 0.5pt solid ; " align="left">mapProperty(Key key) style accessor methods (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">createDefaultVariable</td><td style="border-bottom: 0.5pt solid ; " align="left">generate the default variable (default: true)</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left">defaultVariableName</td><td style="" align="left">name of the default variable</td></tr></tbody></table></div></div><br class="table-break"><p>Below are some examples.</p><p>Customization of Entity type serialization:</p><pre class="programlisting">
<span class="hl-annotation">@Config(entityAccessors=true)</span>
<span class="hl-annotation">@Entity</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> User {
    <span class="hl-comment">//...</span>
}
</pre><p>Customization of package content:</p><pre class="programlisting">
<span class="hl-annotation">@Config(listAccessors=true)</span>
<span class="hl-keyword">package</span> com.querydsl.core.domain.rel;

<span class="hl-keyword">import</span> com.querydsl.core.annotations.Config;
</pre><p>
      If you want to customize the serializer configuration globally,
      you can do this via the following APT options
    </p><div class="table"><a name="d0e2339"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;APT options</b></p><div class="table-contents"><table summary="APT options" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col align="left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Name</th><th style="border-bottom: 0.5pt solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.entityAccessors</td><td style="border-bottom: 0.5pt solid ; " align="left">enable reference field accessors</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.listAccessors</td><td style="border-bottom: 0.5pt solid ; " align="left">enable accessors for direct indexed list access</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.mapAccessors</td><td style="border-bottom: 0.5pt solid ; " align="left">enable accessors for direct key based map access</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.prefix</td><td style="border-bottom: 0.5pt solid ; " align="left">override the prefix for query types(default: Q)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.suffix</td><td style="border-bottom: 0.5pt solid ; " align="left">set a suffix for query types</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.packageSuffix</td><td style="border-bottom: 0.5pt solid ; " align="left">set a suffix for query type packages</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.createDefaultVariable</td><td style="border-bottom: 0.5pt solid ; " align="left">set whether default variables are created</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.unknownAsEmbeddable</td><td style="border-bottom: 0.5pt solid ; " align="left">set where unknown non-annotated classes should be treated as embeddable (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.includedPackages</td><td style="border-bottom: 0.5pt solid ; " align="left">comma separated list of packages to be included into code generation (default: all)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.includedClasses</td><td style="border-bottom: 0.5pt solid ; " align="left">comma separated list of class names to be included into code generation (default: all)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.excludedPackages</td><td style="border-bottom: 0.5pt solid ; " align="left">comma separated list of packages to be excluded from code generation (default: none)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.excludedClasses</td><td style="border-bottom: 0.5pt solid ; " align="left">comma separated list of class names to be excluded from code generation (default: none)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">querydsl.useFields</td><td style="border-bottom: 0.5pt solid ; " align="left">set whether fields are used as metadata source (default: true)</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left">querydsl.useGetters</td><td style="" align="left">set whether accessors are used as metadata source (default: true)</td></tr></tbody></table></div></div><br class="table-break"><p>Using the Maven APT plugin this works for example like this:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
  <span class="hl-tag">&lt;plugins&gt;</span>
    ...
    <span class="hl-tag">&lt;plugin&gt;</span>
      <span class="hl-tag">&lt;groupId&gt;</span>com.mysema.maven<span class="hl-tag">&lt;/groupId&gt;</span>
      <span class="hl-tag">&lt;artifactId&gt;</span>apt-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
      <span class="hl-tag">&lt;version&gt;</span>1.1.3<span class="hl-tag">&lt;/version&gt;</span>
      <span class="hl-tag">&lt;executions&gt;</span>
        <span class="hl-tag">&lt;execution&gt;</span>
          <span class="hl-tag">&lt;goals&gt;</span>
            <span class="hl-tag">&lt;goal&gt;</span>process<span class="hl-tag">&lt;/goal&gt;</span>
          <span class="hl-tag">&lt;/goals&gt;</span>
          <span class="hl-tag">&lt;configuration&gt;</span>
            <span class="hl-tag">&lt;outputDirectory&gt;</span>target/generated-sources/java<span class="hl-tag">&lt;/outputDirectory&gt;</span>
            <span class="hl-tag">&lt;processor&gt;</span>com.querydsl.apt.jpa.JPAAnnotationProcessor<span class="hl-tag">&lt;/processor&gt;</span>
            <span class="hl-tag">&lt;options&gt;</span>
              <span class="hl-tag">&lt;querydsl.entityAccessors&gt;</span>true<span class="hl-tag">&lt;/querydsl.entityAccessors&gt;</span>
              <span class="hl-tag">&lt;querydsl.useFields&gt;</span>false<span class="hl-tag">&lt;/querydsl.useFields&gt;</span>
            <span class="hl-tag">&lt;/options&gt;</span>
          <span class="hl-tag">&lt;/configuration&gt;</span>
        <span class="hl-tag">&lt;/execution&gt;</span>
      <span class="hl-tag">&lt;/executions&gt;</span>
    <span class="hl-tag">&lt;/plugin&gt;</span>
    ...
  <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>
      Alternatively <code class="code">maven-compiler-plugin</code> can be configured
      to hook APT directly into compilation:
    </p><pre class="programlisting">
      <span class="hl-tag">&lt;project&gt;</span>
        <span class="hl-tag">&lt;build&gt;</span>
        <span class="hl-tag">&lt;plugins&gt;</span>
          ...
          <span class="hl-tag">&lt;plugin&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;configuration&gt;</span>
              <span class="hl-tag">&lt;generatedSourcesDirectory&gt;</span>target/generated-sources/java<span class="hl-tag">&lt;/generatedSourcesDirectory&gt;</span>
              <span class="hl-tag">&lt;compilerArgs&gt;</span>
                <span class="hl-tag">&lt;arg&gt;</span>-Aquerydsl.entityAccessors=true<span class="hl-tag">&lt;/arg&gt;</span>
                <span class="hl-tag">&lt;arg&gt;</span>-Aquerydsl.useFields=false<span class="hl-tag">&lt;/arg&gt;</span>
              <span class="hl-tag">&lt;/compilerArgs&gt;</span>
            <span class="hl-tag">&lt;/configuration&gt;</span>
            <span class="hl-tag">&lt;dependencies&gt;</span>
              <span class="hl-tag">&lt;dependency&gt;</span>
                <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
                <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-apt<span class="hl-tag">&lt;/artifactId&gt;</span>
                <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
                <span class="hl-tag">&lt;classifier&gt;</span>jpa<span class="hl-tag">&lt;/classifier&gt;</span>
              <span class="hl-tag">&lt;/dependency&gt;</span>
              <span class="hl-tag">&lt;dependency&gt;</span>
                <span class="hl-tag">&lt;groupId&gt;</span>org.hibernate.javax.persistence<span class="hl-tag">&lt;/groupId&gt;</span>
                <span class="hl-tag">&lt;artifactId&gt;</span>hibernate-jpa-2.1-api<span class="hl-tag">&lt;/artifactId&gt;</span>
                <span class="hl-tag">&lt;version&gt;</span>1.0.0.Final<span class="hl-tag">&lt;/version&gt;</span>
              <span class="hl-tag">&lt;/dependency&gt;</span>
            <span class="hl-tag">&lt;/dependencies&gt;</span>
          <span class="hl-tag">&lt;/plugin&gt;</span>
          ...
        <span class="hl-tag">&lt;/plugins&gt;</span>
        <span class="hl-tag">&lt;/build&gt;</span>
      <span class="hl-tag">&lt;/project&gt;</span>
</pre><p>
      Notice that you need to use a proper classifier when defining dependency
      to <code class="code">com.querydsl:querydsl-apt</code>. Those additional artifacts
      define the annotation processor to be used in
      <code class="code">META-INF/services/javax.annotation.processing.Processor</code>.
    </p><p>Available classifiers include:</p><div class="itemizedlist"><ul type="disc"><li><code class="code">general</code></li><li><code class="code">hibernate</code></li><li><code class="code">jdo</code></li><li><code class="code">jpa</code></li></ul></div><p>
      With this configuration query objects can have their sources generated
      and compiled during compilation of the domain objects. This will also
      automatically add the generated sources directory to Maven project
      source roots.
    </p><p>
      The great advantage of this approach is that it can also handle
      annotated Groovy classes using <code class="code">groovy-eclipse</code> compiler:
    </p><pre class="programlisting">
      <span class="hl-tag">&lt;project&gt;</span>
        <span class="hl-tag">&lt;build&gt;</span>
        <span class="hl-tag">&lt;plugins&gt;</span>
          ...
          <span class="hl-tag">&lt;plugin&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;configuration&gt;</span>
              <span class="hl-tag">&lt;compilerId&gt;</span>groovy-eclipse-compiler<span class="hl-tag">&lt;/compilerId&gt;</span>
              <span class="hl-tag">&lt;generatedSourcesDirectory&gt;</span>target/generated-sources/java<span class="hl-tag">&lt;/generatedSourcesDirectory&gt;</span>
              <span class="hl-tag">&lt;compilerArgs&gt;</span>
                <span class="hl-tag">&lt;arg&gt;</span>-Aquerydsl.entityAccessors=true<span class="hl-tag">&lt;/arg&gt;</span>
                <span class="hl-tag">&lt;arg&gt;</span>-Aquerydsl.useFields=false<span class="hl-tag">&lt;/arg&gt;</span>
              <span class="hl-tag">&lt;/compilerArgs&gt;</span>
            <span class="hl-tag">&lt;/configuration&gt;</span>
            <span class="hl-tag">&lt;dependencies&gt;</span>
              <span class="hl-tag">&lt;dependency&gt;</span>
                <span class="hl-tag">&lt;groupId&gt;</span>org.codehaus.groovy<span class="hl-tag">&lt;/groupId&gt;</span>
                <span class="hl-tag">&lt;artifactId&gt;</span>groovy-eclipse-compiler<span class="hl-tag">&lt;/artifactId&gt;</span>
                <span class="hl-tag">&lt;version&gt;</span>2.9.1-01<span class="hl-tag">&lt;/version&gt;</span>
              <span class="hl-tag">&lt;/dependency&gt;</span>
              <span class="hl-tag">&lt;dependency&gt;</span>
                <span class="hl-tag">&lt;groupId&gt;</span>org.codehaus.groovy<span class="hl-tag">&lt;/groupId&gt;</span>
                <span class="hl-tag">&lt;artifactId&gt;</span>groovy-eclipse-batch<span class="hl-tag">&lt;/artifactId&gt;</span>
                <span class="hl-tag">&lt;version&gt;</span>2.3.7-01<span class="hl-tag">&lt;/version&gt;</span>
              <span class="hl-tag">&lt;/dependency&gt;</span>
              <span class="hl-tag">&lt;dependency&gt;</span>
                <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
                <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-apt<span class="hl-tag">&lt;/artifactId&gt;</span>
                <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
                <span class="hl-tag">&lt;classifier&gt;</span>jpa<span class="hl-tag">&lt;/classifier&gt;</span>
              <span class="hl-tag">&lt;/dependency&gt;</span>
              <span class="hl-tag">&lt;dependency&gt;</span>
                <span class="hl-tag">&lt;groupId&gt;</span>org.hibernate.javax.persistence<span class="hl-tag">&lt;/groupId&gt;</span>
                <span class="hl-tag">&lt;artifactId&gt;</span>hibernate-jpa-2.1-api<span class="hl-tag">&lt;/artifactId&gt;</span>
                <span class="hl-tag">&lt;version&gt;</span>1.0.0.Final<span class="hl-tag">&lt;/version&gt;</span>
              <span class="hl-tag">&lt;/dependency&gt;</span>
            <span class="hl-tag">&lt;/dependencies&gt;</span>
          <span class="hl-tag">&lt;/plugin&gt;</span>
          ...
        <span class="hl-tag">&lt;/plugins&gt;</span>
        <span class="hl-tag">&lt;/build&gt;</span>
      <span class="hl-tag">&lt;/project&gt;</span>
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="custom_types"></a>3.3.3.&nbsp;Custom type mappings</h3></div></div></div><p>
      Custom type mappings can be used on properties to override the derived Path
      type. This can be useful for example in cases where comparison and String operations should
      be blocked on certain String paths or Date / Time support for
      custom types needs to be added. Support for Date / Time types of the Joda time API
      and JDK (java.util.Date, Calendar and subtypes) is built in, but other APIs might need
      to be supported using this feature.
    </p><p>The following example demonstrates the usage:</p><pre class="programlisting">
<span class="hl-annotation">@Entity</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyEntity {
    <span class="hl-annotation">@QueryType(PropertyType.SIMPLE)</span>
    <span class="hl-keyword">public</span> String stringAsSimple;

    <span class="hl-annotation">@QueryType(PropertyType.COMPARABLE)</span>
    <span class="hl-keyword">public</span> String stringAsComparable;

    <span class="hl-annotation">@QueryType(PropertyType.NONE)</span>
    <span class="hl-keyword">public</span> String stringNotInQuerydsl;
}
</pre><p>The value <code class="code">PropertyType.NONE</code> can be used to skip a property in the
      query type generation. This case is different from @Transient or @QueryTransient
      annotated properties, where properties are not persisted. PropertyType.NONE just
      omits the property from the Querydsl query type.
    </p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2479"></a>3.3.4.&nbsp;Delegate methods</h3></div></div></div><p>To declare a static method as a delegate method add the QueryDelegate
      annotation with the corresponding domain type as a value and provide a method
      signature that takes the corresponding Querydsl query type as the first argument.
    </p><p>Here is a simple example from a unit test: </p><pre class="programlisting">
<span class="hl-annotation">@QueryEntity</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">class</span> User {

    String name;

    User manager;

}
</pre><pre class="programlisting">
<span class="hl-annotation">@QueryDelegate(User.class)</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> BooleanPath isManagedBy(QUser user, User other) {
    <span class="hl-keyword">return</span> user.manager.eq(other);
}
</pre><p>And the generated methods in the QUser query type:</p><pre class="programlisting">
<span class="hl-keyword">public</span> BooleanPath isManagedBy(QUser other) {
    <span class="hl-keyword">return</span> DelegateTest.isManagedBy(<span class="hl-keyword">this</span>, other);
}

</pre><p>Delegate methods can also be used to extend built-in types.
      Here are some examples
    </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> QueryExtensions {

    <span class="hl-annotation">@QueryDelegate(Date.class)</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> BooleanExpression inPeriod(DatePath&lt;Date&gt; date, Pair&lt;Date,Date&gt; period) {
        <span class="hl-keyword">return</span> date.goe(period.getFirst()).and(date.loe(period.getSecond()));
    }

    <span class="hl-annotation">@QueryDelegate(Timestamp.class)</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> BooleanExpression inDatePeriod(DateTimePath&lt;Timestamp&gt; timestamp, Pair&lt;Date,Date&gt; period) {
        Timestamp first = <span class="hl-keyword">new</span> Timestamp(DateUtils.truncate(period.getFirst(), Calendar.DAY_OF_MONTH).getTime());
        Calendar second = Calendar.getInstance();
        second.setTime(DateUtils.truncate(period.getSecond(), Calendar.DAY_OF_MONTH));
        second.add(<span class="hl-value">1</span>, Calendar.DAY_OF_MONTH);
        <span class="hl-keyword">return</span> timestamp.goe(first).and(timestamp.lt(<span class="hl-keyword">new</span> Timestamp(second.getTimeInMillis())));
    }

}
</pre><p>When delegate methods are declared for builtin types then subclasses with the
        proper delegate method usages are created:
    </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> QDate <span class="hl-keyword">extends</span> DatePath&lt;java.sql.Date&gt; {

    <span class="hl-keyword">public</span> QDate(BeanPath&lt;? <span class="hl-keyword">extends</span> java.sql.Date&gt; entity) {
        <span class="hl-keyword">super</span>(entity.getType(), entity.getMetadata());
    }

    <span class="hl-keyword">public</span> QDate(PathMetadata&lt;?&gt; metadata) {
        <span class="hl-keyword">super</span>(java.sql.Date.<span class="hl-keyword">class</span>, metadata);
    }

    <span class="hl-keyword">public</span> BooleanExpression inPeriod(com.mysema.commons.lang.Pair&lt;java.sql.Date, java.sql.Date&gt; period) {
        <span class="hl-keyword">return</span> QueryExtensions.inPeriod(<span class="hl-keyword">this</span>, period);
    }

}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> QTimestamp <span class="hl-keyword">extends</span> DateTimePath&lt;java.sql.Timestamp&gt; {

    <span class="hl-keyword">public</span> QTimestamp(BeanPath&lt;? <span class="hl-keyword">extends</span> java.sql.Timestamp&gt; entity) {
        <span class="hl-keyword">super</span>(entity.getType(), entity.getMetadata());
    }

    <span class="hl-keyword">public</span> QTimestamp(PathMetadata&lt;?&gt; metadata) {
        <span class="hl-keyword">super</span>(java.sql.Timestamp.<span class="hl-keyword">class</span>, metadata);
    }

    <span class="hl-keyword">public</span> BooleanExpression inDatePeriod(com.mysema.commons.lang.Pair&lt;java.sql.Date, java.sql.Date&gt; period) {
        <span class="hl-keyword">return</span> QueryExtensions.inDatePeriod(<span class="hl-keyword">this</span>, period);
    }

}
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2502"></a>3.3.5.&nbsp;Non-annotated types</h3></div></div></div><p>
      It is possible to create Querydsl query types for non annotated types by
      creating <code class="code">@QueryEntities</code> annotations. Just place a QueryEntities annotation into a
      package of your choice and the classes to mirrored in the value attribute.
    </p><p>
      To actually create the types use the <code class="code">com.querydsl.apt.QuerydslAnnotationProcessor</code>.
      In Maven you do it like this:
    </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
  <span class="hl-tag">&lt;plugins&gt;</span>
    ...
    <span class="hl-tag">&lt;plugin&gt;</span>
      <span class="hl-tag">&lt;groupId&gt;</span>com.mysema.maven<span class="hl-tag">&lt;/groupId&gt;</span>
      <span class="hl-tag">&lt;artifactId&gt;</span>apt-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
      <span class="hl-tag">&lt;version&gt;</span>1.1.3<span class="hl-tag">&lt;/version&gt;</span>
      <span class="hl-tag">&lt;executions&gt;</span>
        <span class="hl-tag">&lt;execution&gt;</span>
          <span class="hl-tag">&lt;goals&gt;</span>
            <span class="hl-tag">&lt;goal&gt;</span>process<span class="hl-tag">&lt;/goal&gt;</span>
          <span class="hl-tag">&lt;/goals&gt;</span>
          <span class="hl-tag">&lt;configuration&gt;</span>
            <span class="hl-tag">&lt;outputDirectory&gt;</span>target/generated-sources/java<span class="hl-tag">&lt;/outputDirectory&gt;</span>
            <span class="hl-tag">&lt;processor&gt;</span>com.querydsl.apt.QuerydslAnnotationProcessor<span class="hl-tag">&lt;/processor&gt;</span>
          <span class="hl-tag">&lt;/configuration&gt;</span>
        <span class="hl-tag">&lt;/execution&gt;</span>
      <span class="hl-tag">&lt;/executions&gt;</span>
    <span class="hl-tag">&lt;/plugin&gt;</span>
    ...
  <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2517"></a>3.3.6.&nbsp;Classpath based code generation</h3></div></div></div><p>For cases where annotated Java sources
    are not available, such as the usage of a different JVM
    language such as Scala or Groovy or annotation addition via bytecode manipulation the
    <code class="code">GenericExporter</code> class can be used to scan the classpath for annotated classes and
    generate query types for them.
    </p><p>To make GenericExporter available add a dependency to the querydsl-codegen
      module to your project, or to be more precise
      <code class="code">com.querydsl:querydsl-codegen:${querydsl.version}</code>.
    </p><p>Below is an example for JPA</p><pre class="programlisting">
GenericExporter exporter = <span class="hl-keyword">new</span> GenericExporter();
exporter.setKeywords(Keywords.JPA);
exporter.setEntityAnnotation(Entity.<span class="hl-keyword">class</span>);
exporter.setEmbeddableAnnotation(Embeddable.<span class="hl-keyword">class</span>);
exporter.setEmbeddedAnnotation(Embedded.<span class="hl-keyword">class</span>);
exporter.setSupertypeAnnotation(MappedSuperclass.<span class="hl-keyword">class</span>);
exporter.setSkipAnnotation(Transient.<span class="hl-keyword">class</span>);
exporter.setTargetFolder(<span class="hl-keyword">new</span> File(<span class="hl-string">"target/generated-sources/java"</span>));
exporter.export(DomainClass.<span class="hl-keyword">class</span>.getPackage());
</pre><p>This will export all the JPA annotated classes in the package of the DomainClass
      class and subpackages to the target/generated-sources/java directory.
    </p><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2536"></a>3.3.6.1.&nbsp;Usage via Maven</h4></div></div></div><p>The goals generic-export, jpa-export and jdo-export of the querydsl-maven-plugin
        can be used for GenericExporter usage via Maven.
      </p><p>
      The different goals are mapped to the Querydsl, JPA and JDO annotations.
      </p><p>The configuration elements are</p><div class="table"><a name="d0e2545"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Maven configuration</b></p><div class="table-contents"><table summary="Maven configuration" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Type</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Element</th><th style="border-bottom: 0.5pt solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">File</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">targetFolder</td><td style="border-bottom: 0.5pt solid ; " align="left">target folder for generated sources</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">boolean</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">scala</td><td style="border-bottom: 0.5pt solid ; " align="left">true, if Scala sources should be generated instead (default: false)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">String[]</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">packages</td><td style="border-bottom: 0.5pt solid ; " align="left">packages to be introspected for entity classes</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">boolean</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">handleFields</td><td style="border-bottom: 0.5pt solid ; " align="left">true, if fields should be treated as properties (default: true)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">boolean</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">handleMethods</td><td style="border-bottom: 0.5pt solid ; " align="left">true, if getters should be treated as properties (default: true)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">String</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">sourceEncoding</td><td style="border-bottom: 0.5pt solid ; " align="left">charset encoding for the generated source files</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left">boolean</td><td style="border-right: 0.5pt solid ; " align="left">testClasspath</td><td style="" align="left">true, if the test classpath should be used instead</td></tr></tbody></table></div></div><br class="table-break"><p>Here is an example for JPA annotated classes</p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
    <span class="hl-tag">&lt;plugins&gt;</span>
      ...
      <span class="hl-tag">&lt;plugin&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;executions&gt;</span>
          <span class="hl-tag">&lt;execution&gt;</span>
            <span class="hl-tag">&lt;phase&gt;</span>process-classes<span class="hl-tag">&lt;/phase&gt;</span>
            <span class="hl-tag">&lt;goals&gt;</span>
              <span class="hl-tag">&lt;goal&gt;</span>jpa-export<span class="hl-tag">&lt;/goal&gt;</span>
            <span class="hl-tag">&lt;/goals&gt;</span>
            <span class="hl-tag">&lt;configuration&gt;</span>
              <span class="hl-tag">&lt;targetFolder&gt;</span>target/generated-sources/java<span class="hl-tag">&lt;/targetFolder&gt;</span>
              <span class="hl-tag">&lt;packages&gt;</span>
                <span class="hl-tag">&lt;package&gt;</span>com.example.domain<span class="hl-tag">&lt;/package&gt;</span>
              <span class="hl-tag">&lt;/packages&gt;</span>
            <span class="hl-tag">&lt;/configuration&gt;</span>
          <span class="hl-tag">&lt;/execution&gt;</span>
        <span class="hl-tag">&lt;/executions&gt;</span>
      <span class="hl-tag">&lt;/plugin&gt;</span>
      ...
    <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>This will export the JPA annotated classes of the <code class="code">com.example.domain</code> package and
      subpackages to the target/generated-sources/java directory.
      </p><p>If you need to compile the generated sources directly after that, then you can use
      the <code class="code">compile</code> goal for that.</p><pre class="programlisting">
<span class="hl-tag">&lt;execution&gt;</span>
  <span class="hl-tag">&lt;goals&gt;</span>
    <span class="hl-tag">&lt;goal&gt;</span>compile<span class="hl-tag">&lt;/goal&gt;</span>
  <span class="hl-tag">&lt;/goals&gt;</span>
  <span class="hl-tag">&lt;configuration&gt;</span>
    <span class="hl-tag">&lt;sourceFolder&gt;</span>target/generated-sources/scala<span class="hl-tag">&lt;/targetFolder&gt;</span>
  <span class="hl-tag">&lt;/configuration&gt;</span>
<span class="hl-tag">&lt;/execution&gt;</span>
</pre><p>The <code class="code">compile</code> goal has the following configuration elements</p><div class="table"><a name="d0e2631"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Maven configuration</b></p><div class="table-contents"><table summary="Maven configuration" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Type</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">Element</th><th style="border-bottom: 0.5pt solid ; " align="left">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">File</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">sourceFolder</td><td style="border-bottom: 0.5pt solid ; " align="left">source folder with generated sources</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">String</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">sourceEncoding</td><td style="border-bottom: 0.5pt solid ; " align="left">charset encoding of sources</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">String</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">source</td><td style="border-bottom: 0.5pt solid ; " align="left">-source option for the compiler</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">String</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">target</td><td style="border-bottom: 0.5pt solid ; " align="left">-target option for the compiler</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">boolean</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left">testClasspath</td><td style="border-bottom: 0.5pt solid ; " align="left">true, if the test classpath should be used instead</td></tr><tr><td style="border-right: 0.5pt solid ; " align="left">Map</td><td style="border-right: 0.5pt solid ; " align="left">compilerOptions</td><td style="" align="left">options for the compiler</td></tr></tbody></table></div></div><br class="table-break"><p>All options except <code class="code">sourceFolder</code> are optional.</p></div><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2694"></a>3.3.6.2.&nbsp;Scala support</h4></div></div></div><p>If you need Scala output of the classes, use a variant of the following
      configuration
      </p><pre class="programlisting">
<span class="hl-tag">&lt;project&gt;</span>
  <span class="hl-tag">&lt;build&gt;</span>
    <span class="hl-tag">&lt;plugins&gt;</span>
      ...
      <span class="hl-tag">&lt;plugin&gt;</span>
        <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
        <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-maven-plugin<span class="hl-tag">&lt;/artifactId&gt;</span>
        <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
        <span class="hl-tag">&lt;dependencies&gt;</span>
          <span class="hl-tag">&lt;dependency&gt;</span>
            <span class="hl-tag">&lt;groupId&gt;</span>com.querydsl<span class="hl-tag">&lt;/groupId&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>querydsl-scala<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;version&gt;</span>${querydsl.version}<span class="hl-tag">&lt;/version&gt;</span>
          <span class="hl-tag">&lt;/dependency&gt;</span>
          <span class="hl-tag">&lt;dependency&gt;</span>
            <span class="hl-tag">&lt;groupId&gt;</span>org.scala-lang<span class="hl-tag">&lt;/groupId&gt;</span>
            <span class="hl-tag">&lt;artifactId&gt;</span>scala-library<span class="hl-tag">&lt;/artifactId&gt;</span>
            <span class="hl-tag">&lt;version&gt;</span>${scala.version}<span class="hl-tag">&lt;/version&gt;</span>
          <span class="hl-tag">&lt;/dependency&gt;</span>
        <span class="hl-tag">&lt;/dependencies&gt;</span>
        <span class="hl-tag">&lt;executions&gt;</span>
          <span class="hl-tag">&lt;execution&gt;</span>
            <span class="hl-tag">&lt;goals&gt;</span>
              <span class="hl-tag">&lt;goal&gt;</span>jpa-export<span class="hl-tag">&lt;/goal&gt;</span>
            <span class="hl-tag">&lt;/goals&gt;</span>
            <span class="hl-tag">&lt;configuration&gt;</span>
              <span class="hl-tag">&lt;targetFolder&gt;</span>target/generated-sources/scala<span class="hl-tag">&lt;/targetFolder&gt;</span>
              <span class="hl-tag">&lt;scala&gt;</span>true<span class="hl-tag">&lt;/scala&gt;</span>
              <span class="hl-tag">&lt;packages&gt;</span>
                <span class="hl-tag">&lt;package&gt;</span>com.example.domain<span class="hl-tag">&lt;/package&gt;</span>
              <span class="hl-tag">&lt;/packages&gt;</span>
            <span class="hl-tag">&lt;/configuration&gt;</span>
          <span class="hl-tag">&lt;/execution&gt;</span>
        <span class="hl-tag">&lt;/executions&gt;</span>
      <span class="hl-tag">&lt;/plugin&gt;</span>
      ...
    <span class="hl-tag">&lt;/plugins&gt;</span>
  <span class="hl-tag">&lt;/build&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre></div></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="alias"></a>3.4.&nbsp;Alias usage</h2></div></div></div><p>
    In cases where code generation is not an option, alias objects can be used as path
    references for expression construction. They can be used via proxied Java Bean objects
    through getter method invocations.
  </p><p>
    The following examples demonstrate how alias objects can be used as replacements
    for expression creation based on generated types.
  </p><p>
    At first an example query with APT generated domain types:
  </p><pre class="programlisting">
QCat cat = <span class="hl-keyword">new</span> QCat(<span class="hl-string">"cat"</span>);
<span class="hl-keyword">for</span> (String name : queryFactory.select(cat.name).from(cat,cats)
    .where(cat.kittens.size().gt(<span class="hl-value">0</span>))
    .fetch()) {
    System.out.println(name);
}
</pre><p>
    And now with an alias instance for the Cat class. The call <code class="code">c.getKittens()</code> inside
    the dollar-method is internally transformed into the property path <code class="code">c.kittens</code>.
  </p><pre class="programlisting">
Cat c = alias(Cat.<span class="hl-keyword">class</span>, <span class="hl-string">"cat"</span>);
<span class="hl-keyword">for</span> (String name : select($(c.getName())).from($(c),cats)
    .where($(c.getKittens()).size().gt(<span class="hl-value">0</span>))
    .fetch()) {
    System.out.println(name);
}
</pre><p>
    To use the alias functionality in your code, add the following two
    imports
  </p><pre class="programlisting">
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> com.querydsl.core.alias.Alias.$;
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> com.querydsl.core.alias.Alias.alias;
</pre><p>
    The following example is a variation of the previous, where the access to the list
    size happens inside the dollar-method invocation.
  </p><pre class="programlisting">
Cat c = alias(Cat.<span class="hl-keyword">class</span>, <span class="hl-string">"cat"</span>);
<span class="hl-keyword">for</span> (String name : queryFactory.select($(c.getName())).from($(c),cats)
    .where($(c.getKittens().size()).gt(<span class="hl-value">0</span>))
    .fetch()) {
    System.out.println(name);
}
</pre><p>
    All non-primitive and non-final typed properties of aliases are aliases
    themselves. So you may cascade method calls until you hit a primitive or final type
    in the dollar-method scope. e.g.
  </p><pre class="programlisting">
$(c.getMate().getName())
</pre><p>
    is transformed into *c.mate.name* internally, but
  </p><pre class="programlisting">
$(c.getMate().getName().toLowerCase())
</pre><p>
    is not transformed properly, since the <code class="code">toLowerCase()</code> invocation is not tracked.
  </p><p>
    Note also that you may only invoke getters, size(), contains(Object) and get(int)
    on alias types. All other invocations throw exceptions.
  </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a name="troubleshooting"></a>4.&nbsp;Troubleshooting</h2></div></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2748"></a>4.1.&nbsp;Insufficient type arguments</h2></div></div></div><p>
      Querydsl needs properly encoded List Set, Collection and Map properties in all code generation
      scenarios.
    </p><p>When using improperly encoded fields or getters you might the following
      stacktrace:</p><pre class="programlisting">
java.lang.RuntimeException: Caught exception for field com.querydsl.jdo.testdomain.Store#products
  at com.querydsl.apt.Processor$2.visitType(Processor.java:117)
  at com.querydsl.apt.Processor$2.visitType(Processor.java:80)
  at com.sun.tools.javac.code.Symbol$ClassSymbol.accept(Symbol.java:827)
  at com.querydsl.apt.Processor.getClassModel(Processor.java:154)
  at com.querydsl.apt.Processor.process(Processor.java:191)
  ...
Caused by: java.lang.IllegalArgumentException: Insufficient type arguments for List
  at com.querydsl.apt.APTTypeModel.visitDeclared(APTTypeModel.java:112)
  at com.querydsl.apt.APTTypeModel.visitDeclared(APTTypeModel.java:40)
  at com.sun.tools.javac.code.Type$ClassType.accept(Type.java:696)
  at com.querydsl.apt.APTTypeModel.&lt;init&gt;(APTTypeModel.java:55)
  at com.querydsl.apt.APTTypeModel.get(APTTypeModel.java:48)
  at com.querydsl.apt.Processor$2.visitType(Processor.java:114)
  ... 35 more
</pre><p>
      Examples of problematic field declarations and their corrections:
    </p><pre class="programlisting">
    <span class="hl-keyword">private</span> Collection names; <span class="hl-comment">// WRONG</span>

    <span class="hl-keyword">private</span> Collection&lt;String&gt; names; <span class="hl-comment">// RIGHT</span>

    <span class="hl-keyword">private</span> Map employeesByName; <span class="hl-comment">// WRONG</span>

    <span class="hl-keyword">private</span> Map&lt;String,Employee&gt; employeesByName; <span class="hl-comment">// RIGHT</span>
</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2761"></a>4.2.&nbsp;Multithreaded initialization of Querydsl Q-types</h2></div></div></div><p>When Querydsl Q-types are initialized from multiple threads, deadlocks can
      occur, if the Q-types have circular dependencies.</p><p>An easy to use solution is to initialize the classes in a single thread before
      they are used in different threads.</p><p>The com.querydsl.codegen.ClassPathUtils class can be used for that like this:</p><pre class="programlisting">
    ClassPathUtils.scanPackage(Thread.currentThread().getContextClassLoader(), packageToLoad);
</pre><p>Replace packageToLoad with the package of the classes you want to initialize.
    </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2774"></a>4.3.&nbsp;JDK5 usage</h2></div></div></div><p>
      When compiling your project with JDK 5, you might get the following compilation failure:
    </p><pre class="programlisting">
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Compilation failure
...
class file has wrong version 50.0, should be 49.0
</pre><p>
      The class file version 50.0 is used by Java 6.0, and 49.0 is used by Java 5.0.
    </p><p>
      Querydsl is tested against JDK 6.0 only, as we use APT extensively, which is available only
      since JDK 6.0.
    </p><p>
      If you want to use it with JDK 5.0 you might want to try to compile Querydsl yourself.
    </p></div></div></div></body></html>